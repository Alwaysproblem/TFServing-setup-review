// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorflow/core/protobuf/struct.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "tensorflow/core/protobuf/struct.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace tensorflow {

namespace {

const ::google::protobuf::Descriptor* StructuredValue_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  StructuredValue_reflection_ = NULL;
struct StructuredValueOneofInstance {
  const ::tensorflow::NoneValue* none_value_;
  double float64_value_;
  ::google::protobuf::int64 int64_value_;
  ::google::protobuf::internal::ArenaStringPtr string_value_;
  bool bool_value_;
  const ::tensorflow::TensorShapeProto* tensor_shape_value_;
  int tensor_dtype_value_;
  const ::tensorflow::TensorSpecProto* tensor_spec_value_;
  const ::tensorflow::TypeSpecProto* type_spec_value_;
  const ::tensorflow::BoundedTensorSpecProto* bounded_tensor_spec_value_;
  const ::tensorflow::ListValue* list_value_;
  const ::tensorflow::TupleValue* tuple_value_;
  const ::tensorflow::DictValue* dict_value_;
  const ::tensorflow::NamedTupleValue* named_tuple_value_;
}* StructuredValue_default_oneof_instance_ = NULL;
const ::google::protobuf::Descriptor* NoneValue_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NoneValue_reflection_ = NULL;
const ::google::protobuf::Descriptor* ListValue_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ListValue_reflection_ = NULL;
const ::google::protobuf::Descriptor* TupleValue_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TupleValue_reflection_ = NULL;
const ::google::protobuf::Descriptor* DictValue_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DictValue_reflection_ = NULL;
const ::google::protobuf::Descriptor* DictValue_FieldsEntry_descriptor_ = NULL;
const ::google::protobuf::Descriptor* PairValue_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PairValue_reflection_ = NULL;
const ::google::protobuf::Descriptor* NamedTupleValue_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NamedTupleValue_reflection_ = NULL;
const ::google::protobuf::Descriptor* TensorSpecProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TensorSpecProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* BoundedTensorSpecProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BoundedTensorSpecProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* TypeSpecProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TypeSpecProto_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* TypeSpecProto_TypeSpecClass_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_tensorflow_2fcore_2fprotobuf_2fstruct_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AssignDesc_tensorflow_2fcore_2fprotobuf_2fstruct_2eproto() {
  protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fstruct_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "tensorflow/core/protobuf/struct.proto");
  GOOGLE_CHECK(file != NULL);
  StructuredValue_descriptor_ = file->message_type(0);
  static const int StructuredValue_offsets_[15] = {
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(StructuredValue_default_oneof_instance_, none_value_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(StructuredValue_default_oneof_instance_, float64_value_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(StructuredValue_default_oneof_instance_, int64_value_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(StructuredValue_default_oneof_instance_, string_value_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(StructuredValue_default_oneof_instance_, bool_value_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(StructuredValue_default_oneof_instance_, tensor_shape_value_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(StructuredValue_default_oneof_instance_, tensor_dtype_value_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(StructuredValue_default_oneof_instance_, tensor_spec_value_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(StructuredValue_default_oneof_instance_, type_spec_value_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(StructuredValue_default_oneof_instance_, bounded_tensor_spec_value_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(StructuredValue_default_oneof_instance_, list_value_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(StructuredValue_default_oneof_instance_, tuple_value_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(StructuredValue_default_oneof_instance_, dict_value_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(StructuredValue_default_oneof_instance_, named_tuple_value_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StructuredValue, kind_),
  };
  StructuredValue_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      StructuredValue_descriptor_,
      StructuredValue::default_instance_,
      StructuredValue_offsets_,
      -1,
      -1,
      -1,
      StructuredValue_default_oneof_instance_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StructuredValue, _oneof_case_[0]),
      sizeof(StructuredValue),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StructuredValue, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StructuredValue, _is_default_instance_));
  NoneValue_descriptor_ = file->message_type(1);
  static const int NoneValue_offsets_[1] = {
  };
  NoneValue_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      NoneValue_descriptor_,
      NoneValue::default_instance_,
      NoneValue_offsets_,
      -1,
      -1,
      -1,
      sizeof(NoneValue),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NoneValue, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NoneValue, _is_default_instance_));
  ListValue_descriptor_ = file->message_type(2);
  static const int ListValue_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ListValue, values_),
  };
  ListValue_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ListValue_descriptor_,
      ListValue::default_instance_,
      ListValue_offsets_,
      -1,
      -1,
      -1,
      sizeof(ListValue),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ListValue, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ListValue, _is_default_instance_));
  TupleValue_descriptor_ = file->message_type(3);
  static const int TupleValue_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TupleValue, values_),
  };
  TupleValue_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      TupleValue_descriptor_,
      TupleValue::default_instance_,
      TupleValue_offsets_,
      -1,
      -1,
      -1,
      sizeof(TupleValue),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TupleValue, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TupleValue, _is_default_instance_));
  DictValue_descriptor_ = file->message_type(4);
  static const int DictValue_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DictValue, fields_),
  };
  DictValue_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      DictValue_descriptor_,
      DictValue::default_instance_,
      DictValue_offsets_,
      -1,
      -1,
      -1,
      sizeof(DictValue),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DictValue, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DictValue, _is_default_instance_));
  DictValue_FieldsEntry_descriptor_ = DictValue_descriptor_->nested_type(0);
  PairValue_descriptor_ = file->message_type(5);
  static const int PairValue_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PairValue, key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PairValue, value_),
  };
  PairValue_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      PairValue_descriptor_,
      PairValue::default_instance_,
      PairValue_offsets_,
      -1,
      -1,
      -1,
      sizeof(PairValue),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PairValue, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PairValue, _is_default_instance_));
  NamedTupleValue_descriptor_ = file->message_type(6);
  static const int NamedTupleValue_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NamedTupleValue, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NamedTupleValue, values_),
  };
  NamedTupleValue_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      NamedTupleValue_descriptor_,
      NamedTupleValue::default_instance_,
      NamedTupleValue_offsets_,
      -1,
      -1,
      -1,
      sizeof(NamedTupleValue),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NamedTupleValue, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NamedTupleValue, _is_default_instance_));
  TensorSpecProto_descriptor_ = file->message_type(7);
  static const int TensorSpecProto_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TensorSpecProto, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TensorSpecProto, shape_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TensorSpecProto, dtype_),
  };
  TensorSpecProto_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      TensorSpecProto_descriptor_,
      TensorSpecProto::default_instance_,
      TensorSpecProto_offsets_,
      -1,
      -1,
      -1,
      sizeof(TensorSpecProto),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TensorSpecProto, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TensorSpecProto, _is_default_instance_));
  BoundedTensorSpecProto_descriptor_ = file->message_type(8);
  static const int BoundedTensorSpecProto_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BoundedTensorSpecProto, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BoundedTensorSpecProto, shape_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BoundedTensorSpecProto, dtype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BoundedTensorSpecProto, minimum_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BoundedTensorSpecProto, maximum_),
  };
  BoundedTensorSpecProto_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      BoundedTensorSpecProto_descriptor_,
      BoundedTensorSpecProto::default_instance_,
      BoundedTensorSpecProto_offsets_,
      -1,
      -1,
      -1,
      sizeof(BoundedTensorSpecProto),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BoundedTensorSpecProto, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BoundedTensorSpecProto, _is_default_instance_));
  TypeSpecProto_descriptor_ = file->message_type(9);
  static const int TypeSpecProto_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TypeSpecProto, type_spec_class_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TypeSpecProto, type_state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TypeSpecProto, type_spec_class_name_),
  };
  TypeSpecProto_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      TypeSpecProto_descriptor_,
      TypeSpecProto::default_instance_,
      TypeSpecProto_offsets_,
      -1,
      -1,
      -1,
      sizeof(TypeSpecProto),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TypeSpecProto, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TypeSpecProto, _is_default_instance_));
  TypeSpecProto_TypeSpecClass_descriptor_ = TypeSpecProto_descriptor_->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_tensorflow_2fcore_2fprotobuf_2fstruct_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      StructuredValue_descriptor_, &StructuredValue::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      NoneValue_descriptor_, &NoneValue::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ListValue_descriptor_, &ListValue::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      TupleValue_descriptor_, &TupleValue::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      DictValue_descriptor_, &DictValue::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
        DictValue_FieldsEntry_descriptor_,
        ::google::protobuf::internal::MapEntry<
            ::std::string,
            ::tensorflow::StructuredValue,
            ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
            ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
            0>::CreateDefaultInstance(
                DictValue_FieldsEntry_descriptor_));
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      PairValue_descriptor_, &PairValue::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      NamedTupleValue_descriptor_, &NamedTupleValue::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      TensorSpecProto_descriptor_, &TensorSpecProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      BoundedTensorSpecProto_descriptor_, &BoundedTensorSpecProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      TypeSpecProto_descriptor_, &TypeSpecProto::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_tensorflow_2fcore_2fprotobuf_2fstruct_2eproto() {
  delete StructuredValue::default_instance_;
  delete StructuredValue_default_oneof_instance_;
  delete StructuredValue_reflection_;
  delete NoneValue::default_instance_;
  delete NoneValue_reflection_;
  delete ListValue::default_instance_;
  delete ListValue_reflection_;
  delete TupleValue::default_instance_;
  delete TupleValue_reflection_;
  delete DictValue::default_instance_;
  delete DictValue_reflection_;
  delete PairValue::default_instance_;
  delete PairValue_reflection_;
  delete NamedTupleValue::default_instance_;
  delete NamedTupleValue_reflection_;
  delete TensorSpecProto::default_instance_;
  delete TensorSpecProto_reflection_;
  delete BoundedTensorSpecProto::default_instance_;
  delete BoundedTensorSpecProto_reflection_;
  delete TypeSpecProto::default_instance_;
  delete TypeSpecProto_reflection_;
}

void protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fstruct_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fstruct_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::tensorflow::protobuf_AddDesc_tensorflow_2fcore_2fframework_2ftensor_2eproto();
  ::tensorflow::protobuf_AddDesc_tensorflow_2fcore_2fframework_2ftensor_5fshape_2eproto();
  ::tensorflow::protobuf_AddDesc_tensorflow_2fcore_2fframework_2ftypes_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n%tensorflow/core/protobuf/struct.proto\022"
    "\ntensorflow\032&tensorflow/core/framework/t"
    "ensor.proto\032,tensorflow/core/framework/t"
    "ensor_shape.proto\032%tensorflow/core/frame"
    "work/types.proto\"\220\005\n\017StructuredValue\022+\n\n"
    "none_value\030\001 \001(\0132\025.tensorflow.NoneValueH"
    "\000\022\027\n\rfloat64_value\030\013 \001(\001H\000\022\025\n\013int64_valu"
    "e\030\014 \001(\022H\000\022\026\n\014string_value\030\r \001(\tH\000\022\024\n\nboo"
    "l_value\030\016 \001(\010H\000\022:\n\022tensor_shape_value\030\037 "
    "\001(\0132\034.tensorflow.TensorShapeProtoH\000\0222\n\022t"
    "ensor_dtype_value\030  \001(\0162\024.tensorflow.Dat"
    "aTypeH\000\0228\n\021tensor_spec_value\030! \001(\0132\033.ten"
    "sorflow.TensorSpecProtoH\000\0224\n\017type_spec_v"
    "alue\030\" \001(\0132\031.tensorflow.TypeSpecProtoH\000\022"
    "G\n\031bounded_tensor_spec_value\030# \001(\0132\".ten"
    "sorflow.BoundedTensorSpecProtoH\000\022+\n\nlist"
    "_value\0303 \001(\0132\025.tensorflow.ListValueH\000\022-\n"
    "\013tuple_value\0304 \001(\0132\026.tensorflow.TupleVal"
    "ueH\000\022+\n\ndict_value\0305 \001(\0132\025.tensorflow.Di"
    "ctValueH\000\0228\n\021named_tuple_value\0306 \001(\0132\033.t"
    "ensorflow.NamedTupleValueH\000B\006\n\004kind\"\013\n\tN"
    "oneValue\"8\n\tListValue\022+\n\006values\030\001 \003(\0132\033."
    "tensorflow.StructuredValue\"9\n\nTupleValue"
    "\022+\n\006values\030\001 \003(\0132\033.tensorflow.Structured"
    "Value\"\212\001\n\tDictValue\0221\n\006fields\030\001 \003(\0132!.te"
    "nsorflow.DictValue.FieldsEntry\032J\n\013Fields"
    "Entry\022\013\n\003key\030\001 \001(\t\022*\n\005value\030\002 \001(\0132\033.tens"
    "orflow.StructuredValue:\0028\001\"D\n\tPairValue\022"
    "\013\n\003key\030\001 \001(\t\022*\n\005value\030\002 \001(\0132\033.tensorflow"
    ".StructuredValue\"F\n\017NamedTupleValue\022\014\n\004n"
    "ame\030\001 \001(\t\022%\n\006values\030\002 \003(\0132\025.tensorflow.P"
    "airValue\"q\n\017TensorSpecProto\022\014\n\004name\030\001 \001("
    "\t\022+\n\005shape\030\002 \001(\0132\034.tensorflow.TensorShap"
    "eProto\022#\n\005dtype\030\003 \001(\0162\024.tensorflow.DataT"
    "ype\"\314\001\n\026BoundedTensorSpecProto\022\014\n\004name\030\001"
    " \001(\t\022+\n\005shape\030\002 \001(\0132\034.tensorflow.TensorS"
    "hapeProto\022#\n\005dtype\030\003 \001(\0162\024.tensorflow.Da"
    "taType\022(\n\007minimum\030\004 \001(\0132\027.tensorflow.Ten"
    "sorProto\022(\n\007maximum\030\005 \001(\0132\027.tensorflow.T"
    "ensorProto\"\242\003\n\rTypeSpecProto\022@\n\017type_spe"
    "c_class\030\001 \001(\0162\'.tensorflow.TypeSpecProto"
    ".TypeSpecClass\022/\n\ntype_state\030\002 \001(\0132\033.ten"
    "sorflow.StructuredValue\022\034\n\024type_spec_cla"
    "ss_name\030\003 \001(\t\"\377\001\n\rTypeSpecClass\022\013\n\007UNKNO"
    "WN\020\000\022\026\n\022SPARSE_TENSOR_SPEC\020\001\022\027\n\023INDEXED_"
    "SLICES_SPEC\020\002\022\026\n\022RAGGED_TENSOR_SPEC\020\003\022\025\n"
    "\021TENSOR_ARRAY_SPEC\020\004\022\025\n\021DATA_DATASET_SPE"
    "C\020\005\022\026\n\022DATA_ITERATOR_SPEC\020\006\022\021\n\rOPTIONAL_"
    "SPEC\020\007\022\024\n\020PER_REPLICA_SPEC\020\010\022\021\n\rVARIABLE"
    "_SPEC\020\t\022\026\n\022ROW_PARTITION_SPEC\020\nBJZHgithu"
    "b.com/tensorflow/tensorflow/tensorflow/g"
    "o/core/core_protos_go_protob\006proto3", 2075);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "tensorflow/core/protobuf/struct.proto", &protobuf_RegisterTypes);
  StructuredValue::default_instance_ = new StructuredValue();
  StructuredValue_default_oneof_instance_ = new StructuredValueOneofInstance();
  NoneValue::default_instance_ = new NoneValue();
  ListValue::default_instance_ = new ListValue();
  TupleValue::default_instance_ = new TupleValue();
  DictValue::default_instance_ = new DictValue();
  PairValue::default_instance_ = new PairValue();
  NamedTupleValue::default_instance_ = new NamedTupleValue();
  TensorSpecProto::default_instance_ = new TensorSpecProto();
  BoundedTensorSpecProto::default_instance_ = new BoundedTensorSpecProto();
  TypeSpecProto::default_instance_ = new TypeSpecProto();
  StructuredValue::default_instance_->InitAsDefaultInstance();
  NoneValue::default_instance_->InitAsDefaultInstance();
  ListValue::default_instance_->InitAsDefaultInstance();
  TupleValue::default_instance_->InitAsDefaultInstance();
  DictValue::default_instance_->InitAsDefaultInstance();
  PairValue::default_instance_->InitAsDefaultInstance();
  NamedTupleValue::default_instance_->InitAsDefaultInstance();
  TensorSpecProto::default_instance_->InitAsDefaultInstance();
  BoundedTensorSpecProto::default_instance_->InitAsDefaultInstance();
  TypeSpecProto::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_tensorflow_2fcore_2fprotobuf_2fstruct_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_tensorflow_2fcore_2fprotobuf_2fstruct_2eproto {
  StaticDescriptorInitializer_tensorflow_2fcore_2fprotobuf_2fstruct_2eproto() {
    protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fstruct_2eproto();
  }
} static_descriptor_initializer_tensorflow_2fcore_2fprotobuf_2fstruct_2eproto_;

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int StructuredValue::kNoneValueFieldNumber;
const int StructuredValue::kFloat64ValueFieldNumber;
const int StructuredValue::kInt64ValueFieldNumber;
const int StructuredValue::kStringValueFieldNumber;
const int StructuredValue::kBoolValueFieldNumber;
const int StructuredValue::kTensorShapeValueFieldNumber;
const int StructuredValue::kTensorDtypeValueFieldNumber;
const int StructuredValue::kTensorSpecValueFieldNumber;
const int StructuredValue::kTypeSpecValueFieldNumber;
const int StructuredValue::kBoundedTensorSpecValueFieldNumber;
const int StructuredValue::kListValueFieldNumber;
const int StructuredValue::kTupleValueFieldNumber;
const int StructuredValue::kDictValueFieldNumber;
const int StructuredValue::kNamedTupleValueFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

StructuredValue::StructuredValue()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:tensorflow.StructuredValue)
}

void StructuredValue::InitAsDefaultInstance() {
  _is_default_instance_ = true;
  StructuredValue_default_oneof_instance_->none_value_ = const_cast< ::tensorflow::NoneValue*>(&::tensorflow::NoneValue::default_instance());
  StructuredValue_default_oneof_instance_->float64_value_ = 0;
  StructuredValue_default_oneof_instance_->int64_value_ = GOOGLE_LONGLONG(0);
  StructuredValue_default_oneof_instance_->string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  StructuredValue_default_oneof_instance_->bool_value_ = false;
  StructuredValue_default_oneof_instance_->tensor_shape_value_ = const_cast< ::tensorflow::TensorShapeProto*>(&::tensorflow::TensorShapeProto::default_instance());
  StructuredValue_default_oneof_instance_->tensor_dtype_value_ = 0;
  StructuredValue_default_oneof_instance_->tensor_spec_value_ = const_cast< ::tensorflow::TensorSpecProto*>(&::tensorflow::TensorSpecProto::default_instance());
  StructuredValue_default_oneof_instance_->type_spec_value_ = const_cast< ::tensorflow::TypeSpecProto*>(&::tensorflow::TypeSpecProto::default_instance());
  StructuredValue_default_oneof_instance_->bounded_tensor_spec_value_ = const_cast< ::tensorflow::BoundedTensorSpecProto*>(&::tensorflow::BoundedTensorSpecProto::default_instance());
  StructuredValue_default_oneof_instance_->list_value_ = const_cast< ::tensorflow::ListValue*>(&::tensorflow::ListValue::default_instance());
  StructuredValue_default_oneof_instance_->tuple_value_ = const_cast< ::tensorflow::TupleValue*>(&::tensorflow::TupleValue::default_instance());
  StructuredValue_default_oneof_instance_->dict_value_ = const_cast< ::tensorflow::DictValue*>(&::tensorflow::DictValue::default_instance());
  StructuredValue_default_oneof_instance_->named_tuple_value_ = const_cast< ::tensorflow::NamedTupleValue*>(&::tensorflow::NamedTupleValue::default_instance());
}

StructuredValue::StructuredValue(const StructuredValue& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:tensorflow.StructuredValue)
}

void StructuredValue::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  clear_has_kind();
}

StructuredValue::~StructuredValue() {
  // @@protoc_insertion_point(destructor:tensorflow.StructuredValue)
  SharedDtor();
}

void StructuredValue::SharedDtor() {
  if (has_kind()) {
    clear_kind();
  }
  if (this != default_instance_) {
  }
}

void StructuredValue::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* StructuredValue::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StructuredValue_descriptor_;
}

const StructuredValue& StructuredValue::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fstruct_2eproto();
  return *default_instance_;
}

StructuredValue* StructuredValue::default_instance_ = NULL;

StructuredValue* StructuredValue::New(::google::protobuf::Arena* arena) const {
  StructuredValue* n = new StructuredValue;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void StructuredValue::clear_kind() {
// @@protoc_insertion_point(one_of_clear_start:tensorflow.StructuredValue)
  switch(kind_case()) {
    case kNoneValue: {
      delete kind_.none_value_;
      break;
    }
    case kFloat64Value: {
      // No need to clear
      break;
    }
    case kInt64Value: {
      // No need to clear
      break;
    }
    case kStringValue: {
      kind_.string_value_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      break;
    }
    case kBoolValue: {
      // No need to clear
      break;
    }
    case kTensorShapeValue: {
      delete kind_.tensor_shape_value_;
      break;
    }
    case kTensorDtypeValue: {
      // No need to clear
      break;
    }
    case kTensorSpecValue: {
      delete kind_.tensor_spec_value_;
      break;
    }
    case kTypeSpecValue: {
      delete kind_.type_spec_value_;
      break;
    }
    case kBoundedTensorSpecValue: {
      delete kind_.bounded_tensor_spec_value_;
      break;
    }
    case kListValue: {
      delete kind_.list_value_;
      break;
    }
    case kTupleValue: {
      delete kind_.tuple_value_;
      break;
    }
    case kDictValue: {
      delete kind_.dict_value_;
      break;
    }
    case kNamedTupleValue: {
      delete kind_.named_tuple_value_;
      break;
    }
    case KIND_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = KIND_NOT_SET;
}


void StructuredValue::Clear() {
// @@protoc_insertion_point(message_clear_start:tensorflow.StructuredValue)
  clear_kind();
}

bool StructuredValue::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:tensorflow.StructuredValue)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .tensorflow.NoneValue none_value = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_none_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(89)) goto parse_float64_value;
        break;
      }

      // optional double float64_value = 11;
      case 11: {
        if (tag == 89) {
         parse_float64_value:
          clear_kind();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &kind_.float64_value_)));
          set_has_float64_value();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_int64_value;
        break;
      }

      // optional sint64 int64_value = 12;
      case 12: {
        if (tag == 96) {
         parse_int64_value:
          clear_kind();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_SINT64>(
                 input, &kind_.int64_value_)));
          set_has_int64_value();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(106)) goto parse_string_value;
        break;
      }

      // optional string string_value = 13;
      case 13: {
        if (tag == 106) {
         parse_string_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_string_value()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->string_value().data(), this->string_value().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "tensorflow.StructuredValue.string_value"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(112)) goto parse_bool_value;
        break;
      }

      // optional bool bool_value = 14;
      case 14: {
        if (tag == 112) {
         parse_bool_value:
          clear_kind();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &kind_.bool_value_)));
          set_has_bool_value();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(250)) goto parse_tensor_shape_value;
        break;
      }

      // optional .tensorflow.TensorShapeProto tensor_shape_value = 31;
      case 31: {
        if (tag == 250) {
         parse_tensor_shape_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_tensor_shape_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(256)) goto parse_tensor_dtype_value;
        break;
      }

      // optional .tensorflow.DataType tensor_dtype_value = 32;
      case 32: {
        if (tag == 256) {
         parse_tensor_dtype_value:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_tensor_dtype_value(static_cast< ::tensorflow::DataType >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(266)) goto parse_tensor_spec_value;
        break;
      }

      // optional .tensorflow.TensorSpecProto tensor_spec_value = 33;
      case 33: {
        if (tag == 266) {
         parse_tensor_spec_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_tensor_spec_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(274)) goto parse_type_spec_value;
        break;
      }

      // optional .tensorflow.TypeSpecProto type_spec_value = 34;
      case 34: {
        if (tag == 274) {
         parse_type_spec_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_type_spec_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(282)) goto parse_bounded_tensor_spec_value;
        break;
      }

      // optional .tensorflow.BoundedTensorSpecProto bounded_tensor_spec_value = 35;
      case 35: {
        if (tag == 282) {
         parse_bounded_tensor_spec_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_bounded_tensor_spec_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(410)) goto parse_list_value;
        break;
      }

      // optional .tensorflow.ListValue list_value = 51;
      case 51: {
        if (tag == 410) {
         parse_list_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_list_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(418)) goto parse_tuple_value;
        break;
      }

      // optional .tensorflow.TupleValue tuple_value = 52;
      case 52: {
        if (tag == 418) {
         parse_tuple_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_tuple_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(426)) goto parse_dict_value;
        break;
      }

      // optional .tensorflow.DictValue dict_value = 53;
      case 53: {
        if (tag == 426) {
         parse_dict_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_dict_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(434)) goto parse_named_tuple_value;
        break;
      }

      // optional .tensorflow.NamedTupleValue named_tuple_value = 54;
      case 54: {
        if (tag == 434) {
         parse_named_tuple_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_named_tuple_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:tensorflow.StructuredValue)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:tensorflow.StructuredValue)
  return false;
#undef DO_
}

void StructuredValue::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:tensorflow.StructuredValue)
  // optional .tensorflow.NoneValue none_value = 1;
  if (has_none_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *kind_.none_value_, output);
  }

  // optional double float64_value = 11;
  if (has_float64_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(11, this->float64_value(), output);
  }

  // optional sint64 int64_value = 12;
  if (has_int64_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt64(12, this->int64_value(), output);
  }

  // optional string string_value = 13;
  if (has_string_value()) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->string_value().data(), this->string_value().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "tensorflow.StructuredValue.string_value");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      13, this->string_value(), output);
  }

  // optional bool bool_value = 14;
  if (has_bool_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(14, this->bool_value(), output);
  }

  // optional .tensorflow.TensorShapeProto tensor_shape_value = 31;
  if (has_tensor_shape_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      31, *kind_.tensor_shape_value_, output);
  }

  // optional .tensorflow.DataType tensor_dtype_value = 32;
  if (has_tensor_dtype_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      32, this->tensor_dtype_value(), output);
  }

  // optional .tensorflow.TensorSpecProto tensor_spec_value = 33;
  if (has_tensor_spec_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      33, *kind_.tensor_spec_value_, output);
  }

  // optional .tensorflow.TypeSpecProto type_spec_value = 34;
  if (has_type_spec_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      34, *kind_.type_spec_value_, output);
  }

  // optional .tensorflow.BoundedTensorSpecProto bounded_tensor_spec_value = 35;
  if (has_bounded_tensor_spec_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      35, *kind_.bounded_tensor_spec_value_, output);
  }

  // optional .tensorflow.ListValue list_value = 51;
  if (has_list_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      51, *kind_.list_value_, output);
  }

  // optional .tensorflow.TupleValue tuple_value = 52;
  if (has_tuple_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      52, *kind_.tuple_value_, output);
  }

  // optional .tensorflow.DictValue dict_value = 53;
  if (has_dict_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      53, *kind_.dict_value_, output);
  }

  // optional .tensorflow.NamedTupleValue named_tuple_value = 54;
  if (has_named_tuple_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      54, *kind_.named_tuple_value_, output);
  }

  // @@protoc_insertion_point(serialize_end:tensorflow.StructuredValue)
}

::google::protobuf::uint8* StructuredValue::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:tensorflow.StructuredValue)
  // optional .tensorflow.NoneValue none_value = 1;
  if (has_none_value()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *kind_.none_value_, false, target);
  }

  // optional double float64_value = 11;
  if (has_float64_value()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(11, this->float64_value(), target);
  }

  // optional sint64 int64_value = 12;
  if (has_int64_value()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt64ToArray(12, this->int64_value(), target);
  }

  // optional string string_value = 13;
  if (has_string_value()) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->string_value().data(), this->string_value().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "tensorflow.StructuredValue.string_value");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        13, this->string_value(), target);
  }

  // optional bool bool_value = 14;
  if (has_bool_value()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(14, this->bool_value(), target);
  }

  // optional .tensorflow.TensorShapeProto tensor_shape_value = 31;
  if (has_tensor_shape_value()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        31, *kind_.tensor_shape_value_, false, target);
  }

  // optional .tensorflow.DataType tensor_dtype_value = 32;
  if (has_tensor_dtype_value()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      32, this->tensor_dtype_value(), target);
  }

  // optional .tensorflow.TensorSpecProto tensor_spec_value = 33;
  if (has_tensor_spec_value()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        33, *kind_.tensor_spec_value_, false, target);
  }

  // optional .tensorflow.TypeSpecProto type_spec_value = 34;
  if (has_type_spec_value()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        34, *kind_.type_spec_value_, false, target);
  }

  // optional .tensorflow.BoundedTensorSpecProto bounded_tensor_spec_value = 35;
  if (has_bounded_tensor_spec_value()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        35, *kind_.bounded_tensor_spec_value_, false, target);
  }

  // optional .tensorflow.ListValue list_value = 51;
  if (has_list_value()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        51, *kind_.list_value_, false, target);
  }

  // optional .tensorflow.TupleValue tuple_value = 52;
  if (has_tuple_value()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        52, *kind_.tuple_value_, false, target);
  }

  // optional .tensorflow.DictValue dict_value = 53;
  if (has_dict_value()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        53, *kind_.dict_value_, false, target);
  }

  // optional .tensorflow.NamedTupleValue named_tuple_value = 54;
  if (has_named_tuple_value()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        54, *kind_.named_tuple_value_, false, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:tensorflow.StructuredValue)
  return target;
}

int StructuredValue::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:tensorflow.StructuredValue)
  int total_size = 0;

  switch (kind_case()) {
    // optional .tensorflow.NoneValue none_value = 1;
    case kNoneValue: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *kind_.none_value_);
      break;
    }
    // optional double float64_value = 11;
    case kFloat64Value: {
      total_size += 1 + 8;
      break;
    }
    // optional sint64 int64_value = 12;
    case kInt64Value: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt64Size(
          this->int64_value());
      break;
    }
    // optional string string_value = 13;
    case kStringValue: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->string_value());
      break;
    }
    // optional bool bool_value = 14;
    case kBoolValue: {
      total_size += 1 + 1;
      break;
    }
    // optional .tensorflow.TensorShapeProto tensor_shape_value = 31;
    case kTensorShapeValue: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *kind_.tensor_shape_value_);
      break;
    }
    // optional .tensorflow.DataType tensor_dtype_value = 32;
    case kTensorDtypeValue: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->tensor_dtype_value());
      break;
    }
    // optional .tensorflow.TensorSpecProto tensor_spec_value = 33;
    case kTensorSpecValue: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *kind_.tensor_spec_value_);
      break;
    }
    // optional .tensorflow.TypeSpecProto type_spec_value = 34;
    case kTypeSpecValue: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *kind_.type_spec_value_);
      break;
    }
    // optional .tensorflow.BoundedTensorSpecProto bounded_tensor_spec_value = 35;
    case kBoundedTensorSpecValue: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *kind_.bounded_tensor_spec_value_);
      break;
    }
    // optional .tensorflow.ListValue list_value = 51;
    case kListValue: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *kind_.list_value_);
      break;
    }
    // optional .tensorflow.TupleValue tuple_value = 52;
    case kTupleValue: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *kind_.tuple_value_);
      break;
    }
    // optional .tensorflow.DictValue dict_value = 53;
    case kDictValue: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *kind_.dict_value_);
      break;
    }
    // optional .tensorflow.NamedTupleValue named_tuple_value = 54;
    case kNamedTupleValue: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *kind_.named_tuple_value_);
      break;
    }
    case KIND_NOT_SET: {
      break;
    }
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StructuredValue::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:tensorflow.StructuredValue)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const StructuredValue* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const StructuredValue>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:tensorflow.StructuredValue)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:tensorflow.StructuredValue)
    MergeFrom(*source);
  }
}

void StructuredValue::MergeFrom(const StructuredValue& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tensorflow.StructuredValue)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  switch (from.kind_case()) {
    case kNoneValue: {
      mutable_none_value()->::tensorflow::NoneValue::MergeFrom(from.none_value());
      break;
    }
    case kFloat64Value: {
      set_float64_value(from.float64_value());
      break;
    }
    case kInt64Value: {
      set_int64_value(from.int64_value());
      break;
    }
    case kStringValue: {
      set_string_value(from.string_value());
      break;
    }
    case kBoolValue: {
      set_bool_value(from.bool_value());
      break;
    }
    case kTensorShapeValue: {
      mutable_tensor_shape_value()->::tensorflow::TensorShapeProto::MergeFrom(from.tensor_shape_value());
      break;
    }
    case kTensorDtypeValue: {
      set_tensor_dtype_value(from.tensor_dtype_value());
      break;
    }
    case kTensorSpecValue: {
      mutable_tensor_spec_value()->::tensorflow::TensorSpecProto::MergeFrom(from.tensor_spec_value());
      break;
    }
    case kTypeSpecValue: {
      mutable_type_spec_value()->::tensorflow::TypeSpecProto::MergeFrom(from.type_spec_value());
      break;
    }
    case kBoundedTensorSpecValue: {
      mutable_bounded_tensor_spec_value()->::tensorflow::BoundedTensorSpecProto::MergeFrom(from.bounded_tensor_spec_value());
      break;
    }
    case kListValue: {
      mutable_list_value()->::tensorflow::ListValue::MergeFrom(from.list_value());
      break;
    }
    case kTupleValue: {
      mutable_tuple_value()->::tensorflow::TupleValue::MergeFrom(from.tuple_value());
      break;
    }
    case kDictValue: {
      mutable_dict_value()->::tensorflow::DictValue::MergeFrom(from.dict_value());
      break;
    }
    case kNamedTupleValue: {
      mutable_named_tuple_value()->::tensorflow::NamedTupleValue::MergeFrom(from.named_tuple_value());
      break;
    }
    case KIND_NOT_SET: {
      break;
    }
  }
}

void StructuredValue::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:tensorflow.StructuredValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StructuredValue::CopyFrom(const StructuredValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tensorflow.StructuredValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StructuredValue::IsInitialized() const {

  return true;
}

void StructuredValue::Swap(StructuredValue* other) {
  if (other == this) return;
  InternalSwap(other);
}
void StructuredValue::InternalSwap(StructuredValue* other) {
  std::swap(kind_, other->kind_);
  std::swap(_oneof_case_[0], other->_oneof_case_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata StructuredValue::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = StructuredValue_descriptor_;
  metadata.reflection = StructuredValue_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// StructuredValue

// optional .tensorflow.NoneValue none_value = 1;
bool StructuredValue::has_none_value() const {
  return kind_case() == kNoneValue;
}
void StructuredValue::set_has_none_value() {
  _oneof_case_[0] = kNoneValue;
}
void StructuredValue::clear_none_value() {
  if (has_none_value()) {
    delete kind_.none_value_;
    clear_has_kind();
  }
}
 const ::tensorflow::NoneValue& StructuredValue::none_value() const {
  // @@protoc_insertion_point(field_get:tensorflow.StructuredValue.none_value)
  return has_none_value()
      ? *kind_.none_value_
      : ::tensorflow::NoneValue::default_instance();
}
::tensorflow::NoneValue* StructuredValue::mutable_none_value() {
  if (!has_none_value()) {
    clear_kind();
    set_has_none_value();
    kind_.none_value_ = new ::tensorflow::NoneValue;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.StructuredValue.none_value)
  return kind_.none_value_;
}
::tensorflow::NoneValue* StructuredValue::release_none_value() {
  // @@protoc_insertion_point(field_release:tensorflow.StructuredValue.none_value)
  if (has_none_value()) {
    clear_has_kind();
    ::tensorflow::NoneValue* temp = kind_.none_value_;
    kind_.none_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void StructuredValue::set_allocated_none_value(::tensorflow::NoneValue* none_value) {
  clear_kind();
  if (none_value) {
    set_has_none_value();
    kind_.none_value_ = none_value;
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.StructuredValue.none_value)
}

// optional double float64_value = 11;
bool StructuredValue::has_float64_value() const {
  return kind_case() == kFloat64Value;
}
void StructuredValue::set_has_float64_value() {
  _oneof_case_[0] = kFloat64Value;
}
void StructuredValue::clear_float64_value() {
  if (has_float64_value()) {
    kind_.float64_value_ = 0;
    clear_has_kind();
  }
}
 double StructuredValue::float64_value() const {
  // @@protoc_insertion_point(field_get:tensorflow.StructuredValue.float64_value)
  if (has_float64_value()) {
    return kind_.float64_value_;
  }
  return 0;
}
 void StructuredValue::set_float64_value(double value) {
  if (!has_float64_value()) {
    clear_kind();
    set_has_float64_value();
  }
  kind_.float64_value_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.StructuredValue.float64_value)
}

// optional sint64 int64_value = 12;
bool StructuredValue::has_int64_value() const {
  return kind_case() == kInt64Value;
}
void StructuredValue::set_has_int64_value() {
  _oneof_case_[0] = kInt64Value;
}
void StructuredValue::clear_int64_value() {
  if (has_int64_value()) {
    kind_.int64_value_ = GOOGLE_LONGLONG(0);
    clear_has_kind();
  }
}
 ::google::protobuf::int64 StructuredValue::int64_value() const {
  // @@protoc_insertion_point(field_get:tensorflow.StructuredValue.int64_value)
  if (has_int64_value()) {
    return kind_.int64_value_;
  }
  return GOOGLE_LONGLONG(0);
}
 void StructuredValue::set_int64_value(::google::protobuf::int64 value) {
  if (!has_int64_value()) {
    clear_kind();
    set_has_int64_value();
  }
  kind_.int64_value_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.StructuredValue.int64_value)
}

// optional string string_value = 13;
bool StructuredValue::has_string_value() const {
  return kind_case() == kStringValue;
}
void StructuredValue::set_has_string_value() {
  _oneof_case_[0] = kStringValue;
}
void StructuredValue::clear_string_value() {
  if (has_string_value()) {
    kind_.string_value_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_kind();
  }
}
 const ::std::string& StructuredValue::string_value() const {
  // @@protoc_insertion_point(field_get:tensorflow.StructuredValue.string_value)
  if (has_string_value()) {
    return kind_.string_value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
 void StructuredValue::set_string_value(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tensorflow.StructuredValue.string_value)
  if (!has_string_value()) {
    clear_kind();
    set_has_string_value();
    kind_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  kind_.string_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.StructuredValue.string_value)
}
 void StructuredValue::set_string_value(const char* value) {
  if (!has_string_value()) {
    clear_kind();
    set_has_string_value();
    kind_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  kind_.string_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.StructuredValue.string_value)
}
 void StructuredValue::set_string_value(const char* value, size_t size) {
  if (!has_string_value()) {
    clear_kind();
    set_has_string_value();
    kind_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  kind_.string_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.StructuredValue.string_value)
}
 ::std::string* StructuredValue::mutable_string_value() {
  if (!has_string_value()) {
    clear_kind();
    set_has_string_value();
    kind_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.StructuredValue.string_value)
  return kind_.string_value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* StructuredValue::release_string_value() {
  // @@protoc_insertion_point(field_release:tensorflow.StructuredValue.string_value)
  if (has_string_value()) {
    clear_has_kind();
    return kind_.string_value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
 void StructuredValue::set_allocated_string_value(::std::string* string_value) {
  if (!has_string_value()) {
    kind_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_kind();
  if (string_value != NULL) {
    set_has_string_value();
    kind_.string_value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        string_value);
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.StructuredValue.string_value)
}

// optional bool bool_value = 14;
bool StructuredValue::has_bool_value() const {
  return kind_case() == kBoolValue;
}
void StructuredValue::set_has_bool_value() {
  _oneof_case_[0] = kBoolValue;
}
void StructuredValue::clear_bool_value() {
  if (has_bool_value()) {
    kind_.bool_value_ = false;
    clear_has_kind();
  }
}
 bool StructuredValue::bool_value() const {
  // @@protoc_insertion_point(field_get:tensorflow.StructuredValue.bool_value)
  if (has_bool_value()) {
    return kind_.bool_value_;
  }
  return false;
}
 void StructuredValue::set_bool_value(bool value) {
  if (!has_bool_value()) {
    clear_kind();
    set_has_bool_value();
  }
  kind_.bool_value_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.StructuredValue.bool_value)
}

// optional .tensorflow.TensorShapeProto tensor_shape_value = 31;
bool StructuredValue::has_tensor_shape_value() const {
  return kind_case() == kTensorShapeValue;
}
void StructuredValue::set_has_tensor_shape_value() {
  _oneof_case_[0] = kTensorShapeValue;
}
void StructuredValue::clear_tensor_shape_value() {
  if (has_tensor_shape_value()) {
    delete kind_.tensor_shape_value_;
    clear_has_kind();
  }
}
 const ::tensorflow::TensorShapeProto& StructuredValue::tensor_shape_value() const {
  // @@protoc_insertion_point(field_get:tensorflow.StructuredValue.tensor_shape_value)
  return has_tensor_shape_value()
      ? *kind_.tensor_shape_value_
      : ::tensorflow::TensorShapeProto::default_instance();
}
::tensorflow::TensorShapeProto* StructuredValue::mutable_tensor_shape_value() {
  if (!has_tensor_shape_value()) {
    clear_kind();
    set_has_tensor_shape_value();
    kind_.tensor_shape_value_ = new ::tensorflow::TensorShapeProto;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.StructuredValue.tensor_shape_value)
  return kind_.tensor_shape_value_;
}
::tensorflow::TensorShapeProto* StructuredValue::release_tensor_shape_value() {
  // @@protoc_insertion_point(field_release:tensorflow.StructuredValue.tensor_shape_value)
  if (has_tensor_shape_value()) {
    clear_has_kind();
    ::tensorflow::TensorShapeProto* temp = kind_.tensor_shape_value_;
    kind_.tensor_shape_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void StructuredValue::set_allocated_tensor_shape_value(::tensorflow::TensorShapeProto* tensor_shape_value) {
  clear_kind();
  if (tensor_shape_value) {
    if (static_cast< ::tensorflow::TensorShapeProto*>(tensor_shape_value)->GetArena() != NULL) {
      ::tensorflow::TensorShapeProto* new_tensor_shape_value = new ::tensorflow::TensorShapeProto;
      new_tensor_shape_value->CopyFrom(*tensor_shape_value);
      tensor_shape_value = new_tensor_shape_value;
    }
    set_has_tensor_shape_value();
    kind_.tensor_shape_value_ = tensor_shape_value;
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.StructuredValue.tensor_shape_value)
}

// optional .tensorflow.DataType tensor_dtype_value = 32;
bool StructuredValue::has_tensor_dtype_value() const {
  return kind_case() == kTensorDtypeValue;
}
void StructuredValue::set_has_tensor_dtype_value() {
  _oneof_case_[0] = kTensorDtypeValue;
}
void StructuredValue::clear_tensor_dtype_value() {
  if (has_tensor_dtype_value()) {
    kind_.tensor_dtype_value_ = 0;
    clear_has_kind();
  }
}
 ::tensorflow::DataType StructuredValue::tensor_dtype_value() const {
  // @@protoc_insertion_point(field_get:tensorflow.StructuredValue.tensor_dtype_value)
  if (has_tensor_dtype_value()) {
    return static_cast< ::tensorflow::DataType >(kind_.tensor_dtype_value_);
  }
  return static_cast< ::tensorflow::DataType >(0);
}
 void StructuredValue::set_tensor_dtype_value(::tensorflow::DataType value) {
  if (!has_tensor_dtype_value()) {
    clear_kind();
    set_has_tensor_dtype_value();
  }
  kind_.tensor_dtype_value_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.StructuredValue.tensor_dtype_value)
}

// optional .tensorflow.TensorSpecProto tensor_spec_value = 33;
bool StructuredValue::has_tensor_spec_value() const {
  return kind_case() == kTensorSpecValue;
}
void StructuredValue::set_has_tensor_spec_value() {
  _oneof_case_[0] = kTensorSpecValue;
}
void StructuredValue::clear_tensor_spec_value() {
  if (has_tensor_spec_value()) {
    delete kind_.tensor_spec_value_;
    clear_has_kind();
  }
}
 const ::tensorflow::TensorSpecProto& StructuredValue::tensor_spec_value() const {
  // @@protoc_insertion_point(field_get:tensorflow.StructuredValue.tensor_spec_value)
  return has_tensor_spec_value()
      ? *kind_.tensor_spec_value_
      : ::tensorflow::TensorSpecProto::default_instance();
}
::tensorflow::TensorSpecProto* StructuredValue::mutable_tensor_spec_value() {
  if (!has_tensor_spec_value()) {
    clear_kind();
    set_has_tensor_spec_value();
    kind_.tensor_spec_value_ = new ::tensorflow::TensorSpecProto;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.StructuredValue.tensor_spec_value)
  return kind_.tensor_spec_value_;
}
::tensorflow::TensorSpecProto* StructuredValue::release_tensor_spec_value() {
  // @@protoc_insertion_point(field_release:tensorflow.StructuredValue.tensor_spec_value)
  if (has_tensor_spec_value()) {
    clear_has_kind();
    ::tensorflow::TensorSpecProto* temp = kind_.tensor_spec_value_;
    kind_.tensor_spec_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void StructuredValue::set_allocated_tensor_spec_value(::tensorflow::TensorSpecProto* tensor_spec_value) {
  clear_kind();
  if (tensor_spec_value) {
    set_has_tensor_spec_value();
    kind_.tensor_spec_value_ = tensor_spec_value;
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.StructuredValue.tensor_spec_value)
}

// optional .tensorflow.TypeSpecProto type_spec_value = 34;
bool StructuredValue::has_type_spec_value() const {
  return kind_case() == kTypeSpecValue;
}
void StructuredValue::set_has_type_spec_value() {
  _oneof_case_[0] = kTypeSpecValue;
}
void StructuredValue::clear_type_spec_value() {
  if (has_type_spec_value()) {
    delete kind_.type_spec_value_;
    clear_has_kind();
  }
}
 const ::tensorflow::TypeSpecProto& StructuredValue::type_spec_value() const {
  // @@protoc_insertion_point(field_get:tensorflow.StructuredValue.type_spec_value)
  return has_type_spec_value()
      ? *kind_.type_spec_value_
      : ::tensorflow::TypeSpecProto::default_instance();
}
::tensorflow::TypeSpecProto* StructuredValue::mutable_type_spec_value() {
  if (!has_type_spec_value()) {
    clear_kind();
    set_has_type_spec_value();
    kind_.type_spec_value_ = new ::tensorflow::TypeSpecProto;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.StructuredValue.type_spec_value)
  return kind_.type_spec_value_;
}
::tensorflow::TypeSpecProto* StructuredValue::release_type_spec_value() {
  // @@protoc_insertion_point(field_release:tensorflow.StructuredValue.type_spec_value)
  if (has_type_spec_value()) {
    clear_has_kind();
    ::tensorflow::TypeSpecProto* temp = kind_.type_spec_value_;
    kind_.type_spec_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void StructuredValue::set_allocated_type_spec_value(::tensorflow::TypeSpecProto* type_spec_value) {
  clear_kind();
  if (type_spec_value) {
    set_has_type_spec_value();
    kind_.type_spec_value_ = type_spec_value;
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.StructuredValue.type_spec_value)
}

// optional .tensorflow.BoundedTensorSpecProto bounded_tensor_spec_value = 35;
bool StructuredValue::has_bounded_tensor_spec_value() const {
  return kind_case() == kBoundedTensorSpecValue;
}
void StructuredValue::set_has_bounded_tensor_spec_value() {
  _oneof_case_[0] = kBoundedTensorSpecValue;
}
void StructuredValue::clear_bounded_tensor_spec_value() {
  if (has_bounded_tensor_spec_value()) {
    delete kind_.bounded_tensor_spec_value_;
    clear_has_kind();
  }
}
 const ::tensorflow::BoundedTensorSpecProto& StructuredValue::bounded_tensor_spec_value() const {
  // @@protoc_insertion_point(field_get:tensorflow.StructuredValue.bounded_tensor_spec_value)
  return has_bounded_tensor_spec_value()
      ? *kind_.bounded_tensor_spec_value_
      : ::tensorflow::BoundedTensorSpecProto::default_instance();
}
::tensorflow::BoundedTensorSpecProto* StructuredValue::mutable_bounded_tensor_spec_value() {
  if (!has_bounded_tensor_spec_value()) {
    clear_kind();
    set_has_bounded_tensor_spec_value();
    kind_.bounded_tensor_spec_value_ = new ::tensorflow::BoundedTensorSpecProto;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.StructuredValue.bounded_tensor_spec_value)
  return kind_.bounded_tensor_spec_value_;
}
::tensorflow::BoundedTensorSpecProto* StructuredValue::release_bounded_tensor_spec_value() {
  // @@protoc_insertion_point(field_release:tensorflow.StructuredValue.bounded_tensor_spec_value)
  if (has_bounded_tensor_spec_value()) {
    clear_has_kind();
    ::tensorflow::BoundedTensorSpecProto* temp = kind_.bounded_tensor_spec_value_;
    kind_.bounded_tensor_spec_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void StructuredValue::set_allocated_bounded_tensor_spec_value(::tensorflow::BoundedTensorSpecProto* bounded_tensor_spec_value) {
  clear_kind();
  if (bounded_tensor_spec_value) {
    set_has_bounded_tensor_spec_value();
    kind_.bounded_tensor_spec_value_ = bounded_tensor_spec_value;
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.StructuredValue.bounded_tensor_spec_value)
}

// optional .tensorflow.ListValue list_value = 51;
bool StructuredValue::has_list_value() const {
  return kind_case() == kListValue;
}
void StructuredValue::set_has_list_value() {
  _oneof_case_[0] = kListValue;
}
void StructuredValue::clear_list_value() {
  if (has_list_value()) {
    delete kind_.list_value_;
    clear_has_kind();
  }
}
 const ::tensorflow::ListValue& StructuredValue::list_value() const {
  // @@protoc_insertion_point(field_get:tensorflow.StructuredValue.list_value)
  return has_list_value()
      ? *kind_.list_value_
      : ::tensorflow::ListValue::default_instance();
}
::tensorflow::ListValue* StructuredValue::mutable_list_value() {
  if (!has_list_value()) {
    clear_kind();
    set_has_list_value();
    kind_.list_value_ = new ::tensorflow::ListValue;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.StructuredValue.list_value)
  return kind_.list_value_;
}
::tensorflow::ListValue* StructuredValue::release_list_value() {
  // @@protoc_insertion_point(field_release:tensorflow.StructuredValue.list_value)
  if (has_list_value()) {
    clear_has_kind();
    ::tensorflow::ListValue* temp = kind_.list_value_;
    kind_.list_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void StructuredValue::set_allocated_list_value(::tensorflow::ListValue* list_value) {
  clear_kind();
  if (list_value) {
    set_has_list_value();
    kind_.list_value_ = list_value;
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.StructuredValue.list_value)
}

// optional .tensorflow.TupleValue tuple_value = 52;
bool StructuredValue::has_tuple_value() const {
  return kind_case() == kTupleValue;
}
void StructuredValue::set_has_tuple_value() {
  _oneof_case_[0] = kTupleValue;
}
void StructuredValue::clear_tuple_value() {
  if (has_tuple_value()) {
    delete kind_.tuple_value_;
    clear_has_kind();
  }
}
 const ::tensorflow::TupleValue& StructuredValue::tuple_value() const {
  // @@protoc_insertion_point(field_get:tensorflow.StructuredValue.tuple_value)
  return has_tuple_value()
      ? *kind_.tuple_value_
      : ::tensorflow::TupleValue::default_instance();
}
::tensorflow::TupleValue* StructuredValue::mutable_tuple_value() {
  if (!has_tuple_value()) {
    clear_kind();
    set_has_tuple_value();
    kind_.tuple_value_ = new ::tensorflow::TupleValue;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.StructuredValue.tuple_value)
  return kind_.tuple_value_;
}
::tensorflow::TupleValue* StructuredValue::release_tuple_value() {
  // @@protoc_insertion_point(field_release:tensorflow.StructuredValue.tuple_value)
  if (has_tuple_value()) {
    clear_has_kind();
    ::tensorflow::TupleValue* temp = kind_.tuple_value_;
    kind_.tuple_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void StructuredValue::set_allocated_tuple_value(::tensorflow::TupleValue* tuple_value) {
  clear_kind();
  if (tuple_value) {
    set_has_tuple_value();
    kind_.tuple_value_ = tuple_value;
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.StructuredValue.tuple_value)
}

// optional .tensorflow.DictValue dict_value = 53;
bool StructuredValue::has_dict_value() const {
  return kind_case() == kDictValue;
}
void StructuredValue::set_has_dict_value() {
  _oneof_case_[0] = kDictValue;
}
void StructuredValue::clear_dict_value() {
  if (has_dict_value()) {
    delete kind_.dict_value_;
    clear_has_kind();
  }
}
 const ::tensorflow::DictValue& StructuredValue::dict_value() const {
  // @@protoc_insertion_point(field_get:tensorflow.StructuredValue.dict_value)
  return has_dict_value()
      ? *kind_.dict_value_
      : ::tensorflow::DictValue::default_instance();
}
::tensorflow::DictValue* StructuredValue::mutable_dict_value() {
  if (!has_dict_value()) {
    clear_kind();
    set_has_dict_value();
    kind_.dict_value_ = new ::tensorflow::DictValue;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.StructuredValue.dict_value)
  return kind_.dict_value_;
}
::tensorflow::DictValue* StructuredValue::release_dict_value() {
  // @@protoc_insertion_point(field_release:tensorflow.StructuredValue.dict_value)
  if (has_dict_value()) {
    clear_has_kind();
    ::tensorflow::DictValue* temp = kind_.dict_value_;
    kind_.dict_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void StructuredValue::set_allocated_dict_value(::tensorflow::DictValue* dict_value) {
  clear_kind();
  if (dict_value) {
    set_has_dict_value();
    kind_.dict_value_ = dict_value;
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.StructuredValue.dict_value)
}

// optional .tensorflow.NamedTupleValue named_tuple_value = 54;
bool StructuredValue::has_named_tuple_value() const {
  return kind_case() == kNamedTupleValue;
}
void StructuredValue::set_has_named_tuple_value() {
  _oneof_case_[0] = kNamedTupleValue;
}
void StructuredValue::clear_named_tuple_value() {
  if (has_named_tuple_value()) {
    delete kind_.named_tuple_value_;
    clear_has_kind();
  }
}
 const ::tensorflow::NamedTupleValue& StructuredValue::named_tuple_value() const {
  // @@protoc_insertion_point(field_get:tensorflow.StructuredValue.named_tuple_value)
  return has_named_tuple_value()
      ? *kind_.named_tuple_value_
      : ::tensorflow::NamedTupleValue::default_instance();
}
::tensorflow::NamedTupleValue* StructuredValue::mutable_named_tuple_value() {
  if (!has_named_tuple_value()) {
    clear_kind();
    set_has_named_tuple_value();
    kind_.named_tuple_value_ = new ::tensorflow::NamedTupleValue;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.StructuredValue.named_tuple_value)
  return kind_.named_tuple_value_;
}
::tensorflow::NamedTupleValue* StructuredValue::release_named_tuple_value() {
  // @@protoc_insertion_point(field_release:tensorflow.StructuredValue.named_tuple_value)
  if (has_named_tuple_value()) {
    clear_has_kind();
    ::tensorflow::NamedTupleValue* temp = kind_.named_tuple_value_;
    kind_.named_tuple_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void StructuredValue::set_allocated_named_tuple_value(::tensorflow::NamedTupleValue* named_tuple_value) {
  clear_kind();
  if (named_tuple_value) {
    set_has_named_tuple_value();
    kind_.named_tuple_value_ = named_tuple_value;
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.StructuredValue.named_tuple_value)
}

bool StructuredValue::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
void StructuredValue::clear_has_kind() {
  _oneof_case_[0] = KIND_NOT_SET;
}
StructuredValue::KindCase StructuredValue::kind_case() const {
  return StructuredValue::KindCase(_oneof_case_[0]);
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

NoneValue::NoneValue()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:tensorflow.NoneValue)
}

void NoneValue::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

NoneValue::NoneValue(const NoneValue& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:tensorflow.NoneValue)
}

void NoneValue::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
}

NoneValue::~NoneValue() {
  // @@protoc_insertion_point(destructor:tensorflow.NoneValue)
  SharedDtor();
}

void NoneValue::SharedDtor() {
  if (this != default_instance_) {
  }
}

void NoneValue::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NoneValue::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NoneValue_descriptor_;
}

const NoneValue& NoneValue::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fstruct_2eproto();
  return *default_instance_;
}

NoneValue* NoneValue::default_instance_ = NULL;

NoneValue* NoneValue::New(::google::protobuf::Arena* arena) const {
  NoneValue* n = new NoneValue;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void NoneValue::Clear() {
// @@protoc_insertion_point(message_clear_start:tensorflow.NoneValue)
}

bool NoneValue::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:tensorflow.NoneValue)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
  }
success:
  // @@protoc_insertion_point(parse_success:tensorflow.NoneValue)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:tensorflow.NoneValue)
  return false;
#undef DO_
}

void NoneValue::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:tensorflow.NoneValue)
  // @@protoc_insertion_point(serialize_end:tensorflow.NoneValue)
}

::google::protobuf::uint8* NoneValue::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:tensorflow.NoneValue)
  // @@protoc_insertion_point(serialize_to_array_end:tensorflow.NoneValue)
  return target;
}

int NoneValue::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:tensorflow.NoneValue)
  int total_size = 0;

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NoneValue::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:tensorflow.NoneValue)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const NoneValue* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const NoneValue>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:tensorflow.NoneValue)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:tensorflow.NoneValue)
    MergeFrom(*source);
  }
}

void NoneValue::MergeFrom(const NoneValue& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tensorflow.NoneValue)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
}

void NoneValue::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:tensorflow.NoneValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NoneValue::CopyFrom(const NoneValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tensorflow.NoneValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NoneValue::IsInitialized() const {

  return true;
}

void NoneValue::Swap(NoneValue* other) {
  if (other == this) return;
  InternalSwap(other);
}
void NoneValue::InternalSwap(NoneValue* other) {
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata NoneValue::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NoneValue_descriptor_;
  metadata.reflection = NoneValue_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// NoneValue

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ListValue::kValuesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ListValue::ListValue()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:tensorflow.ListValue)
}

void ListValue::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

ListValue::ListValue(const ListValue& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:tensorflow.ListValue)
}

void ListValue::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
}

ListValue::~ListValue() {
  // @@protoc_insertion_point(destructor:tensorflow.ListValue)
  SharedDtor();
}

void ListValue::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ListValue::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ListValue::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ListValue_descriptor_;
}

const ListValue& ListValue::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fstruct_2eproto();
  return *default_instance_;
}

ListValue* ListValue::default_instance_ = NULL;

ListValue* ListValue::New(::google::protobuf::Arena* arena) const {
  ListValue* n = new ListValue;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ListValue::Clear() {
// @@protoc_insertion_point(message_clear_start:tensorflow.ListValue)
  values_.Clear();
}

bool ListValue::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:tensorflow.ListValue)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .tensorflow.StructuredValue values = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_values:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_values()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_values;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:tensorflow.ListValue)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:tensorflow.ListValue)
  return false;
#undef DO_
}

void ListValue::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:tensorflow.ListValue)
  // repeated .tensorflow.StructuredValue values = 1;
  for (unsigned int i = 0, n = this->values_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->values(i), output);
  }

  // @@protoc_insertion_point(serialize_end:tensorflow.ListValue)
}

::google::protobuf::uint8* ListValue::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:tensorflow.ListValue)
  // repeated .tensorflow.StructuredValue values = 1;
  for (unsigned int i = 0, n = this->values_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, this->values(i), false, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:tensorflow.ListValue)
  return target;
}

int ListValue::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:tensorflow.ListValue)
  int total_size = 0;

  // repeated .tensorflow.StructuredValue values = 1;
  total_size += 1 * this->values_size();
  for (int i = 0; i < this->values_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->values(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ListValue::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:tensorflow.ListValue)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ListValue* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ListValue>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:tensorflow.ListValue)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:tensorflow.ListValue)
    MergeFrom(*source);
  }
}

void ListValue::MergeFrom(const ListValue& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tensorflow.ListValue)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  values_.MergeFrom(from.values_);
}

void ListValue::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:tensorflow.ListValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ListValue::CopyFrom(const ListValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tensorflow.ListValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListValue::IsInitialized() const {

  return true;
}

void ListValue::Swap(ListValue* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ListValue::InternalSwap(ListValue* other) {
  values_.UnsafeArenaSwap(&other->values_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ListValue::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ListValue_descriptor_;
  metadata.reflection = ListValue_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ListValue

// repeated .tensorflow.StructuredValue values = 1;
int ListValue::values_size() const {
  return values_.size();
}
void ListValue::clear_values() {
  values_.Clear();
}
const ::tensorflow::StructuredValue& ListValue::values(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.ListValue.values)
  return values_.Get(index);
}
::tensorflow::StructuredValue* ListValue::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.ListValue.values)
  return values_.Mutable(index);
}
::tensorflow::StructuredValue* ListValue::add_values() {
  // @@protoc_insertion_point(field_add:tensorflow.ListValue.values)
  return values_.Add();
}
::google::protobuf::RepeatedPtrField< ::tensorflow::StructuredValue >*
ListValue::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.ListValue.values)
  return &values_;
}
const ::google::protobuf::RepeatedPtrField< ::tensorflow::StructuredValue >&
ListValue::values() const {
  // @@protoc_insertion_point(field_list:tensorflow.ListValue.values)
  return values_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TupleValue::kValuesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TupleValue::TupleValue()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:tensorflow.TupleValue)
}

void TupleValue::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

TupleValue::TupleValue(const TupleValue& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:tensorflow.TupleValue)
}

void TupleValue::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
}

TupleValue::~TupleValue() {
  // @@protoc_insertion_point(destructor:tensorflow.TupleValue)
  SharedDtor();
}

void TupleValue::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TupleValue::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TupleValue::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TupleValue_descriptor_;
}

const TupleValue& TupleValue::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fstruct_2eproto();
  return *default_instance_;
}

TupleValue* TupleValue::default_instance_ = NULL;

TupleValue* TupleValue::New(::google::protobuf::Arena* arena) const {
  TupleValue* n = new TupleValue;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TupleValue::Clear() {
// @@protoc_insertion_point(message_clear_start:tensorflow.TupleValue)
  values_.Clear();
}

bool TupleValue::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:tensorflow.TupleValue)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .tensorflow.StructuredValue values = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_values:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_values()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_values;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:tensorflow.TupleValue)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:tensorflow.TupleValue)
  return false;
#undef DO_
}

void TupleValue::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:tensorflow.TupleValue)
  // repeated .tensorflow.StructuredValue values = 1;
  for (unsigned int i = 0, n = this->values_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->values(i), output);
  }

  // @@protoc_insertion_point(serialize_end:tensorflow.TupleValue)
}

::google::protobuf::uint8* TupleValue::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:tensorflow.TupleValue)
  // repeated .tensorflow.StructuredValue values = 1;
  for (unsigned int i = 0, n = this->values_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, this->values(i), false, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:tensorflow.TupleValue)
  return target;
}

int TupleValue::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:tensorflow.TupleValue)
  int total_size = 0;

  // repeated .tensorflow.StructuredValue values = 1;
  total_size += 1 * this->values_size();
  for (int i = 0; i < this->values_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->values(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TupleValue::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:tensorflow.TupleValue)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const TupleValue* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const TupleValue>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:tensorflow.TupleValue)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:tensorflow.TupleValue)
    MergeFrom(*source);
  }
}

void TupleValue::MergeFrom(const TupleValue& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tensorflow.TupleValue)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  values_.MergeFrom(from.values_);
}

void TupleValue::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:tensorflow.TupleValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TupleValue::CopyFrom(const TupleValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tensorflow.TupleValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TupleValue::IsInitialized() const {

  return true;
}

void TupleValue::Swap(TupleValue* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TupleValue::InternalSwap(TupleValue* other) {
  values_.UnsafeArenaSwap(&other->values_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TupleValue::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TupleValue_descriptor_;
  metadata.reflection = TupleValue_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TupleValue

// repeated .tensorflow.StructuredValue values = 1;
int TupleValue::values_size() const {
  return values_.size();
}
void TupleValue::clear_values() {
  values_.Clear();
}
const ::tensorflow::StructuredValue& TupleValue::values(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.TupleValue.values)
  return values_.Get(index);
}
::tensorflow::StructuredValue* TupleValue::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.TupleValue.values)
  return values_.Mutable(index);
}
::tensorflow::StructuredValue* TupleValue::add_values() {
  // @@protoc_insertion_point(field_add:tensorflow.TupleValue.values)
  return values_.Add();
}
::google::protobuf::RepeatedPtrField< ::tensorflow::StructuredValue >*
TupleValue::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.TupleValue.values)
  return &values_;
}
const ::google::protobuf::RepeatedPtrField< ::tensorflow::StructuredValue >&
TupleValue::values() const {
  // @@protoc_insertion_point(field_list:tensorflow.TupleValue.values)
  return values_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DictValue::kFieldsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DictValue::DictValue()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:tensorflow.DictValue)
}

void DictValue::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

DictValue::DictValue(const DictValue& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:tensorflow.DictValue)
}

void DictValue::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  fields_.SetAssignDescriptorCallback(
      protobuf_AssignDescriptorsOnce);
  fields_.SetEntryDescriptor(
      &::tensorflow::DictValue_FieldsEntry_descriptor_);
}

DictValue::~DictValue() {
  // @@protoc_insertion_point(destructor:tensorflow.DictValue)
  SharedDtor();
}

void DictValue::SharedDtor() {
  if (this != default_instance_) {
  }
}

void DictValue::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DictValue::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DictValue_descriptor_;
}

const DictValue& DictValue::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fstruct_2eproto();
  return *default_instance_;
}

DictValue* DictValue::default_instance_ = NULL;

DictValue* DictValue::New(::google::protobuf::Arena* arena) const {
  DictValue* n = new DictValue;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DictValue::Clear() {
// @@protoc_insertion_point(message_clear_start:tensorflow.DictValue)
  fields_.Clear();
}

bool DictValue::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:tensorflow.DictValue)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // map<string, .tensorflow.StructuredValue> fields = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_fields:
          DictValue_FieldsEntry::Parser< ::google::protobuf::internal::MapField<
              ::std::string, ::tensorflow::StructuredValue,
              ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
              ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
              0 >,
            ::google::protobuf::Map< ::std::string, ::tensorflow::StructuredValue > > parser(&fields_);
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
              input, &parser));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            parser.key().data(), parser.key().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "tensorflow.DictValue.FieldsEntry.key"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_fields;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:tensorflow.DictValue)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:tensorflow.DictValue)
  return false;
#undef DO_
}

void DictValue::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:tensorflow.DictValue)
  // map<string, .tensorflow.StructuredValue> fields = 1;
  if (!this->fields().empty()) {
    typedef ::google::protobuf::Map< ::std::string, ::tensorflow::StructuredValue >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::google::protobuf::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), p->first.length(),
          ::google::protobuf::internal::WireFormatLite::SERIALIZE,
          "tensorflow.DictValue.FieldsEntry.key");
      }
    };

    if (output->IsSerializationDeterminstic() &&
        this->fields().size() > 1) {
      ::google::protobuf::scoped_array<SortItem> items(
          new SortItem[this->fields().size()]);
      typedef ::google::protobuf::Map< ::std::string, ::tensorflow::StructuredValue >::size_type size_type;
      size_type n = 0;
      for (::google::protobuf::Map< ::std::string, ::tensorflow::StructuredValue >::const_iterator
          it = this->fields().begin();
          it != this->fields().end(); ++it, ++n) {
        items[n] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[n], Less());
      ::google::protobuf::scoped_ptr<DictValue_FieldsEntry> entry;
      for (size_type i = 0; i < n; i++) {
        entry.reset(fields_.NewEntryWrapper(
            items[i]->first, items[i]->second));
        ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
            1, *entry, output);
        Utf8Check::Check(items[i]);
      }
    } else {
      ::google::protobuf::scoped_ptr<DictValue_FieldsEntry> entry;
      for (::google::protobuf::Map< ::std::string, ::tensorflow::StructuredValue >::const_iterator
          it = this->fields().begin();
          it != this->fields().end(); ++it) {
        entry.reset(fields_.NewEntryWrapper(
            it->first, it->second));
        ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
            1, *entry, output);
        Utf8Check::Check(&*it);
      }
    }
  }

  // @@protoc_insertion_point(serialize_end:tensorflow.DictValue)
}

::google::protobuf::uint8* DictValue::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:tensorflow.DictValue)
  // map<string, .tensorflow.StructuredValue> fields = 1;
  if (!this->fields().empty()) {
    typedef ::google::protobuf::Map< ::std::string, ::tensorflow::StructuredValue >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::google::protobuf::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), p->first.length(),
          ::google::protobuf::internal::WireFormatLite::SERIALIZE,
          "tensorflow.DictValue.FieldsEntry.key");
      }
    };

    if (deterministic &&
        this->fields().size() > 1) {
      ::google::protobuf::scoped_array<SortItem> items(
          new SortItem[this->fields().size()]);
      typedef ::google::protobuf::Map< ::std::string, ::tensorflow::StructuredValue >::size_type size_type;
      size_type n = 0;
      for (::google::protobuf::Map< ::std::string, ::tensorflow::StructuredValue >::const_iterator
          it = this->fields().begin();
          it != this->fields().end(); ++it, ++n) {
        items[n] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[n], Less());
      ::google::protobuf::scoped_ptr<DictValue_FieldsEntry> entry;
      for (size_type i = 0; i < n; i++) {
        entry.reset(fields_.NewEntryWrapper(
            items[i]->first, items[i]->second));
        target = ::google::protobuf::internal::WireFormatLite::
                   InternalWriteMessageNoVirtualToArray(
                       1, *entry, deterministic, target);
;
        Utf8Check::Check(items[i]);
      }
    } else {
      ::google::protobuf::scoped_ptr<DictValue_FieldsEntry> entry;
      for (::google::protobuf::Map< ::std::string, ::tensorflow::StructuredValue >::const_iterator
          it = this->fields().begin();
          it != this->fields().end(); ++it) {
        entry.reset(fields_.NewEntryWrapper(
            it->first, it->second));
        target = ::google::protobuf::internal::WireFormatLite::
                   InternalWriteMessageNoVirtualToArray(
                       1, *entry, deterministic, target);
;
        Utf8Check::Check(&*it);
      }
    }
  }

  // @@protoc_insertion_point(serialize_to_array_end:tensorflow.DictValue)
  return target;
}

int DictValue::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:tensorflow.DictValue)
  int total_size = 0;

  // map<string, .tensorflow.StructuredValue> fields = 1;
  total_size += 1 * this->fields_size();
  {
    ::google::protobuf::scoped_ptr<DictValue_FieldsEntry> entry;
    for (::google::protobuf::Map< ::std::string, ::tensorflow::StructuredValue >::const_iterator
        it = this->fields().begin();
        it != this->fields().end(); ++it) {
      entry.reset(fields_.NewEntryWrapper(it->first, it->second));
      total_size += ::google::protobuf::internal::WireFormatLite::
          MessageSizeNoVirtual(*entry);
    }
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DictValue::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:tensorflow.DictValue)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const DictValue* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const DictValue>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:tensorflow.DictValue)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:tensorflow.DictValue)
    MergeFrom(*source);
  }
}

void DictValue::MergeFrom(const DictValue& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tensorflow.DictValue)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  fields_.MergeFrom(from.fields_);
}

void DictValue::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:tensorflow.DictValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DictValue::CopyFrom(const DictValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tensorflow.DictValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DictValue::IsInitialized() const {

  return true;
}

void DictValue::Swap(DictValue* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DictValue::InternalSwap(DictValue* other) {
  fields_.Swap(&other->fields_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata DictValue::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DictValue_descriptor_;
  metadata.reflection = DictValue_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DictValue

// map<string, .tensorflow.StructuredValue> fields = 1;
int DictValue::fields_size() const {
  return fields_.size();
}
void DictValue::clear_fields() {
  fields_.Clear();
}
 const ::google::protobuf::Map< ::std::string, ::tensorflow::StructuredValue >&
DictValue::fields() const {
  // @@protoc_insertion_point(field_map:tensorflow.DictValue.fields)
  return fields_.GetMap();
}
 ::google::protobuf::Map< ::std::string, ::tensorflow::StructuredValue >*
DictValue::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_map:tensorflow.DictValue.fields)
  return fields_.MutableMap();
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PairValue::kKeyFieldNumber;
const int PairValue::kValueFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PairValue::PairValue()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:tensorflow.PairValue)
}

void PairValue::InitAsDefaultInstance() {
  _is_default_instance_ = true;
  value_ = const_cast< ::tensorflow::StructuredValue*>(&::tensorflow::StructuredValue::default_instance());
}

PairValue::PairValue(const PairValue& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:tensorflow.PairValue)
}

void PairValue::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  value_ = NULL;
}

PairValue::~PairValue() {
  // @@protoc_insertion_point(destructor:tensorflow.PairValue)
  SharedDtor();
}

void PairValue::SharedDtor() {
  key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete value_;
  }
}

void PairValue::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PairValue::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PairValue_descriptor_;
}

const PairValue& PairValue::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fstruct_2eproto();
  return *default_instance_;
}

PairValue* PairValue::default_instance_ = NULL;

PairValue* PairValue::New(::google::protobuf::Arena* arena) const {
  PairValue* n = new PairValue;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PairValue::Clear() {
// @@protoc_insertion_point(message_clear_start:tensorflow.PairValue)
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (GetArenaNoVirtual() == NULL && value_ != NULL) delete value_;
  value_ = NULL;
}

bool PairValue::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:tensorflow.PairValue)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string key = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_key()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->key().data(), this->key().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "tensorflow.PairValue.key"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_value;
        break;
      }

      // optional .tensorflow.StructuredValue value = 2;
      case 2: {
        if (tag == 18) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:tensorflow.PairValue)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:tensorflow.PairValue)
  return false;
#undef DO_
}

void PairValue::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:tensorflow.PairValue)
  // optional string key = 1;
  if (this->key().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->key().data(), this->key().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "tensorflow.PairValue.key");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->key(), output);
  }

  // optional .tensorflow.StructuredValue value = 2;
  if (this->has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->value_, output);
  }

  // @@protoc_insertion_point(serialize_end:tensorflow.PairValue)
}

::google::protobuf::uint8* PairValue::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:tensorflow.PairValue)
  // optional string key = 1;
  if (this->key().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->key().data(), this->key().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "tensorflow.PairValue.key");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->key(), target);
  }

  // optional .tensorflow.StructuredValue value = 2;
  if (this->has_value()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->value_, false, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:tensorflow.PairValue)
  return target;
}

int PairValue::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:tensorflow.PairValue)
  int total_size = 0;

  // optional string key = 1;
  if (this->key().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->key());
  }

  // optional .tensorflow.StructuredValue value = 2;
  if (this->has_value()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->value_);
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PairValue::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:tensorflow.PairValue)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const PairValue* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const PairValue>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:tensorflow.PairValue)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:tensorflow.PairValue)
    MergeFrom(*source);
  }
}

void PairValue::MergeFrom(const PairValue& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tensorflow.PairValue)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.key().size() > 0) {

    key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.key_);
  }
  if (from.has_value()) {
    mutable_value()->::tensorflow::StructuredValue::MergeFrom(from.value());
  }
}

void PairValue::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:tensorflow.PairValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PairValue::CopyFrom(const PairValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tensorflow.PairValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PairValue::IsInitialized() const {

  return true;
}

void PairValue::Swap(PairValue* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PairValue::InternalSwap(PairValue* other) {
  key_.Swap(&other->key_);
  std::swap(value_, other->value_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata PairValue::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PairValue_descriptor_;
  metadata.reflection = PairValue_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PairValue

// optional string key = 1;
void PairValue::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& PairValue::key() const {
  // @@protoc_insertion_point(field_get:tensorflow.PairValue.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void PairValue::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.PairValue.key)
}
 void PairValue::set_key(const char* value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.PairValue.key)
}
 void PairValue::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.PairValue.key)
}
 ::std::string* PairValue::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.PairValue.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* PairValue::release_key() {
  // @@protoc_insertion_point(field_release:tensorflow.PairValue.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void PairValue::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.PairValue.key)
}

// optional .tensorflow.StructuredValue value = 2;
bool PairValue::has_value() const {
  return !_is_default_instance_ && value_ != NULL;
}
void PairValue::clear_value() {
  if (GetArenaNoVirtual() == NULL && value_ != NULL) delete value_;
  value_ = NULL;
}
const ::tensorflow::StructuredValue& PairValue::value() const {
  // @@protoc_insertion_point(field_get:tensorflow.PairValue.value)
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
::tensorflow::StructuredValue* PairValue::mutable_value() {
  
  if (value_ == NULL) {
    value_ = new ::tensorflow::StructuredValue;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.PairValue.value)
  return value_;
}
::tensorflow::StructuredValue* PairValue::release_value() {
  // @@protoc_insertion_point(field_release:tensorflow.PairValue.value)
  
  ::tensorflow::StructuredValue* temp = value_;
  value_ = NULL;
  return temp;
}
void PairValue::set_allocated_value(::tensorflow::StructuredValue* value) {
  delete value_;
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.PairValue.value)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int NamedTupleValue::kNameFieldNumber;
const int NamedTupleValue::kValuesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

NamedTupleValue::NamedTupleValue()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:tensorflow.NamedTupleValue)
}

void NamedTupleValue::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

NamedTupleValue::NamedTupleValue(const NamedTupleValue& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:tensorflow.NamedTupleValue)
}

void NamedTupleValue::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

NamedTupleValue::~NamedTupleValue() {
  // @@protoc_insertion_point(destructor:tensorflow.NamedTupleValue)
  SharedDtor();
}

void NamedTupleValue::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void NamedTupleValue::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NamedTupleValue::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NamedTupleValue_descriptor_;
}

const NamedTupleValue& NamedTupleValue::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fstruct_2eproto();
  return *default_instance_;
}

NamedTupleValue* NamedTupleValue::default_instance_ = NULL;

NamedTupleValue* NamedTupleValue::New(::google::protobuf::Arena* arena) const {
  NamedTupleValue* n = new NamedTupleValue;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void NamedTupleValue::Clear() {
// @@protoc_insertion_point(message_clear_start:tensorflow.NamedTupleValue)
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  values_.Clear();
}

bool NamedTupleValue::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:tensorflow.NamedTupleValue)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "tensorflow.NamedTupleValue.name"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_values;
        break;
      }

      // repeated .tensorflow.PairValue values = 2;
      case 2: {
        if (tag == 18) {
         parse_values:
          DO_(input->IncrementRecursionDepth());
         parse_loop_values:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_values()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_values;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:tensorflow.NamedTupleValue)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:tensorflow.NamedTupleValue)
  return false;
#undef DO_
}

void NamedTupleValue::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:tensorflow.NamedTupleValue)
  // optional string name = 1;
  if (this->name().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "tensorflow.NamedTupleValue.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // repeated .tensorflow.PairValue values = 2;
  for (unsigned int i = 0, n = this->values_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->values(i), output);
  }

  // @@protoc_insertion_point(serialize_end:tensorflow.NamedTupleValue)
}

::google::protobuf::uint8* NamedTupleValue::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:tensorflow.NamedTupleValue)
  // optional string name = 1;
  if (this->name().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "tensorflow.NamedTupleValue.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // repeated .tensorflow.PairValue values = 2;
  for (unsigned int i = 0, n = this->values_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, this->values(i), false, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:tensorflow.NamedTupleValue)
  return target;
}

int NamedTupleValue::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:tensorflow.NamedTupleValue)
  int total_size = 0;

  // optional string name = 1;
  if (this->name().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }

  // repeated .tensorflow.PairValue values = 2;
  total_size += 1 * this->values_size();
  for (int i = 0; i < this->values_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->values(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NamedTupleValue::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:tensorflow.NamedTupleValue)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const NamedTupleValue* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const NamedTupleValue>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:tensorflow.NamedTupleValue)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:tensorflow.NamedTupleValue)
    MergeFrom(*source);
  }
}

void NamedTupleValue::MergeFrom(const NamedTupleValue& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tensorflow.NamedTupleValue)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  values_.MergeFrom(from.values_);
  if (from.name().size() > 0) {

    name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
}

void NamedTupleValue::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:tensorflow.NamedTupleValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NamedTupleValue::CopyFrom(const NamedTupleValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tensorflow.NamedTupleValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NamedTupleValue::IsInitialized() const {

  return true;
}

void NamedTupleValue::Swap(NamedTupleValue* other) {
  if (other == this) return;
  InternalSwap(other);
}
void NamedTupleValue::InternalSwap(NamedTupleValue* other) {
  name_.Swap(&other->name_);
  values_.UnsafeArenaSwap(&other->values_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata NamedTupleValue::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NamedTupleValue_descriptor_;
  metadata.reflection = NamedTupleValue_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// NamedTupleValue

// optional string name = 1;
void NamedTupleValue::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& NamedTupleValue::name() const {
  // @@protoc_insertion_point(field_get:tensorflow.NamedTupleValue.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void NamedTupleValue::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.NamedTupleValue.name)
}
 void NamedTupleValue::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.NamedTupleValue.name)
}
 void NamedTupleValue::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.NamedTupleValue.name)
}
 ::std::string* NamedTupleValue::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.NamedTupleValue.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* NamedTupleValue::release_name() {
  // @@protoc_insertion_point(field_release:tensorflow.NamedTupleValue.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void NamedTupleValue::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.NamedTupleValue.name)
}

// repeated .tensorflow.PairValue values = 2;
int NamedTupleValue::values_size() const {
  return values_.size();
}
void NamedTupleValue::clear_values() {
  values_.Clear();
}
const ::tensorflow::PairValue& NamedTupleValue::values(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.NamedTupleValue.values)
  return values_.Get(index);
}
::tensorflow::PairValue* NamedTupleValue::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.NamedTupleValue.values)
  return values_.Mutable(index);
}
::tensorflow::PairValue* NamedTupleValue::add_values() {
  // @@protoc_insertion_point(field_add:tensorflow.NamedTupleValue.values)
  return values_.Add();
}
::google::protobuf::RepeatedPtrField< ::tensorflow::PairValue >*
NamedTupleValue::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.NamedTupleValue.values)
  return &values_;
}
const ::google::protobuf::RepeatedPtrField< ::tensorflow::PairValue >&
NamedTupleValue::values() const {
  // @@protoc_insertion_point(field_list:tensorflow.NamedTupleValue.values)
  return values_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TensorSpecProto::kNameFieldNumber;
const int TensorSpecProto::kShapeFieldNumber;
const int TensorSpecProto::kDtypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TensorSpecProto::TensorSpecProto()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:tensorflow.TensorSpecProto)
}

void TensorSpecProto::InitAsDefaultInstance() {
  _is_default_instance_ = true;
  shape_ = const_cast< ::tensorflow::TensorShapeProto*>(&::tensorflow::TensorShapeProto::default_instance());
}

TensorSpecProto::TensorSpecProto(const TensorSpecProto& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:tensorflow.TensorSpecProto)
}

void TensorSpecProto::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  shape_ = NULL;
  dtype_ = 0;
}

TensorSpecProto::~TensorSpecProto() {
  // @@protoc_insertion_point(destructor:tensorflow.TensorSpecProto)
  SharedDtor();
}

void TensorSpecProto::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete shape_;
  }
}

void TensorSpecProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TensorSpecProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TensorSpecProto_descriptor_;
}

const TensorSpecProto& TensorSpecProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fstruct_2eproto();
  return *default_instance_;
}

TensorSpecProto* TensorSpecProto::default_instance_ = NULL;

TensorSpecProto* TensorSpecProto::New(::google::protobuf::Arena* arena) const {
  TensorSpecProto* n = new TensorSpecProto;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TensorSpecProto::Clear() {
// @@protoc_insertion_point(message_clear_start:tensorflow.TensorSpecProto)
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (GetArenaNoVirtual() == NULL && shape_ != NULL) delete shape_;
  shape_ = NULL;
  dtype_ = 0;
}

bool TensorSpecProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:tensorflow.TensorSpecProto)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "tensorflow.TensorSpecProto.name"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_shape;
        break;
      }

      // optional .tensorflow.TensorShapeProto shape = 2;
      case 2: {
        if (tag == 18) {
         parse_shape:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_shape()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_dtype;
        break;
      }

      // optional .tensorflow.DataType dtype = 3;
      case 3: {
        if (tag == 24) {
         parse_dtype:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_dtype(static_cast< ::tensorflow::DataType >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:tensorflow.TensorSpecProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:tensorflow.TensorSpecProto)
  return false;
#undef DO_
}

void TensorSpecProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:tensorflow.TensorSpecProto)
  // optional string name = 1;
  if (this->name().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "tensorflow.TensorSpecProto.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional .tensorflow.TensorShapeProto shape = 2;
  if (this->has_shape()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->shape_, output);
  }

  // optional .tensorflow.DataType dtype = 3;
  if (this->dtype() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->dtype(), output);
  }

  // @@protoc_insertion_point(serialize_end:tensorflow.TensorSpecProto)
}

::google::protobuf::uint8* TensorSpecProto::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:tensorflow.TensorSpecProto)
  // optional string name = 1;
  if (this->name().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "tensorflow.TensorSpecProto.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // optional .tensorflow.TensorShapeProto shape = 2;
  if (this->has_shape()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->shape_, false, target);
  }

  // optional .tensorflow.DataType dtype = 3;
  if (this->dtype() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->dtype(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:tensorflow.TensorSpecProto)
  return target;
}

int TensorSpecProto::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:tensorflow.TensorSpecProto)
  int total_size = 0;

  // optional string name = 1;
  if (this->name().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }

  // optional .tensorflow.TensorShapeProto shape = 2;
  if (this->has_shape()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->shape_);
  }

  // optional .tensorflow.DataType dtype = 3;
  if (this->dtype() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->dtype());
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TensorSpecProto::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:tensorflow.TensorSpecProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const TensorSpecProto* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const TensorSpecProto>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:tensorflow.TensorSpecProto)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:tensorflow.TensorSpecProto)
    MergeFrom(*source);
  }
}

void TensorSpecProto::MergeFrom(const TensorSpecProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tensorflow.TensorSpecProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.name().size() > 0) {

    name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  if (from.has_shape()) {
    mutable_shape()->::tensorflow::TensorShapeProto::MergeFrom(from.shape());
  }
  if (from.dtype() != 0) {
    set_dtype(from.dtype());
  }
}

void TensorSpecProto::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:tensorflow.TensorSpecProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TensorSpecProto::CopyFrom(const TensorSpecProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tensorflow.TensorSpecProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TensorSpecProto::IsInitialized() const {

  return true;
}

void TensorSpecProto::Swap(TensorSpecProto* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TensorSpecProto::InternalSwap(TensorSpecProto* other) {
  name_.Swap(&other->name_);
  std::swap(shape_, other->shape_);
  std::swap(dtype_, other->dtype_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TensorSpecProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TensorSpecProto_descriptor_;
  metadata.reflection = TensorSpecProto_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TensorSpecProto

// optional string name = 1;
void TensorSpecProto::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& TensorSpecProto::name() const {
  // @@protoc_insertion_point(field_get:tensorflow.TensorSpecProto.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TensorSpecProto::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.TensorSpecProto.name)
}
 void TensorSpecProto::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.TensorSpecProto.name)
}
 void TensorSpecProto::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.TensorSpecProto.name)
}
 ::std::string* TensorSpecProto::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.TensorSpecProto.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* TensorSpecProto::release_name() {
  // @@protoc_insertion_point(field_release:tensorflow.TensorSpecProto.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TensorSpecProto::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TensorSpecProto.name)
}

// optional .tensorflow.TensorShapeProto shape = 2;
bool TensorSpecProto::has_shape() const {
  return !_is_default_instance_ && shape_ != NULL;
}
void TensorSpecProto::clear_shape() {
  if (GetArenaNoVirtual() == NULL && shape_ != NULL) delete shape_;
  shape_ = NULL;
}
const ::tensorflow::TensorShapeProto& TensorSpecProto::shape() const {
  // @@protoc_insertion_point(field_get:tensorflow.TensorSpecProto.shape)
  return shape_ != NULL ? *shape_ : *default_instance_->shape_;
}
::tensorflow::TensorShapeProto* TensorSpecProto::mutable_shape() {
  
  if (shape_ == NULL) {
    shape_ = new ::tensorflow::TensorShapeProto;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.TensorSpecProto.shape)
  return shape_;
}
::tensorflow::TensorShapeProto* TensorSpecProto::release_shape() {
  // @@protoc_insertion_point(field_release:tensorflow.TensorSpecProto.shape)
  
  ::tensorflow::TensorShapeProto* temp = shape_;
  shape_ = NULL;
  return temp;
}
void TensorSpecProto::set_allocated_shape(::tensorflow::TensorShapeProto* shape) {
  delete shape_;
  if (shape != NULL && shape->GetArena() != NULL) {
    ::tensorflow::TensorShapeProto* new_shape = new ::tensorflow::TensorShapeProto;
    new_shape->CopyFrom(*shape);
    shape = new_shape;
  }
  shape_ = shape;
  if (shape) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TensorSpecProto.shape)
}

// optional .tensorflow.DataType dtype = 3;
void TensorSpecProto::clear_dtype() {
  dtype_ = 0;
}
 ::tensorflow::DataType TensorSpecProto::dtype() const {
  // @@protoc_insertion_point(field_get:tensorflow.TensorSpecProto.dtype)
  return static_cast< ::tensorflow::DataType >(dtype_);
}
 void TensorSpecProto::set_dtype(::tensorflow::DataType value) {
  
  dtype_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.TensorSpecProto.dtype)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int BoundedTensorSpecProto::kNameFieldNumber;
const int BoundedTensorSpecProto::kShapeFieldNumber;
const int BoundedTensorSpecProto::kDtypeFieldNumber;
const int BoundedTensorSpecProto::kMinimumFieldNumber;
const int BoundedTensorSpecProto::kMaximumFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

BoundedTensorSpecProto::BoundedTensorSpecProto()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:tensorflow.BoundedTensorSpecProto)
}

void BoundedTensorSpecProto::InitAsDefaultInstance() {
  _is_default_instance_ = true;
  shape_ = const_cast< ::tensorflow::TensorShapeProto*>(&::tensorflow::TensorShapeProto::default_instance());
  minimum_ = const_cast< ::tensorflow::TensorProto*>(&::tensorflow::TensorProto::default_instance());
  maximum_ = const_cast< ::tensorflow::TensorProto*>(&::tensorflow::TensorProto::default_instance());
}

BoundedTensorSpecProto::BoundedTensorSpecProto(const BoundedTensorSpecProto& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:tensorflow.BoundedTensorSpecProto)
}

void BoundedTensorSpecProto::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  shape_ = NULL;
  dtype_ = 0;
  minimum_ = NULL;
  maximum_ = NULL;
}

BoundedTensorSpecProto::~BoundedTensorSpecProto() {
  // @@protoc_insertion_point(destructor:tensorflow.BoundedTensorSpecProto)
  SharedDtor();
}

void BoundedTensorSpecProto::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete shape_;
    delete minimum_;
    delete maximum_;
  }
}

void BoundedTensorSpecProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BoundedTensorSpecProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BoundedTensorSpecProto_descriptor_;
}

const BoundedTensorSpecProto& BoundedTensorSpecProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fstruct_2eproto();
  return *default_instance_;
}

BoundedTensorSpecProto* BoundedTensorSpecProto::default_instance_ = NULL;

BoundedTensorSpecProto* BoundedTensorSpecProto::New(::google::protobuf::Arena* arena) const {
  BoundedTensorSpecProto* n = new BoundedTensorSpecProto;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void BoundedTensorSpecProto::Clear() {
// @@protoc_insertion_point(message_clear_start:tensorflow.BoundedTensorSpecProto)
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (GetArenaNoVirtual() == NULL && shape_ != NULL) delete shape_;
  shape_ = NULL;
  dtype_ = 0;
  if (GetArenaNoVirtual() == NULL && minimum_ != NULL) delete minimum_;
  minimum_ = NULL;
  if (GetArenaNoVirtual() == NULL && maximum_ != NULL) delete maximum_;
  maximum_ = NULL;
}

bool BoundedTensorSpecProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:tensorflow.BoundedTensorSpecProto)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "tensorflow.BoundedTensorSpecProto.name"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_shape;
        break;
      }

      // optional .tensorflow.TensorShapeProto shape = 2;
      case 2: {
        if (tag == 18) {
         parse_shape:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_shape()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_dtype;
        break;
      }

      // optional .tensorflow.DataType dtype = 3;
      case 3: {
        if (tag == 24) {
         parse_dtype:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_dtype(static_cast< ::tensorflow::DataType >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_minimum;
        break;
      }

      // optional .tensorflow.TensorProto minimum = 4;
      case 4: {
        if (tag == 34) {
         parse_minimum:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_minimum()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_maximum;
        break;
      }

      // optional .tensorflow.TensorProto maximum = 5;
      case 5: {
        if (tag == 42) {
         parse_maximum:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_maximum()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:tensorflow.BoundedTensorSpecProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:tensorflow.BoundedTensorSpecProto)
  return false;
#undef DO_
}

void BoundedTensorSpecProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:tensorflow.BoundedTensorSpecProto)
  // optional string name = 1;
  if (this->name().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "tensorflow.BoundedTensorSpecProto.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional .tensorflow.TensorShapeProto shape = 2;
  if (this->has_shape()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->shape_, output);
  }

  // optional .tensorflow.DataType dtype = 3;
  if (this->dtype() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->dtype(), output);
  }

  // optional .tensorflow.TensorProto minimum = 4;
  if (this->has_minimum()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->minimum_, output);
  }

  // optional .tensorflow.TensorProto maximum = 5;
  if (this->has_maximum()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->maximum_, output);
  }

  // @@protoc_insertion_point(serialize_end:tensorflow.BoundedTensorSpecProto)
}

::google::protobuf::uint8* BoundedTensorSpecProto::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:tensorflow.BoundedTensorSpecProto)
  // optional string name = 1;
  if (this->name().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "tensorflow.BoundedTensorSpecProto.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // optional .tensorflow.TensorShapeProto shape = 2;
  if (this->has_shape()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->shape_, false, target);
  }

  // optional .tensorflow.DataType dtype = 3;
  if (this->dtype() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->dtype(), target);
  }

  // optional .tensorflow.TensorProto minimum = 4;
  if (this->has_minimum()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->minimum_, false, target);
  }

  // optional .tensorflow.TensorProto maximum = 5;
  if (this->has_maximum()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, *this->maximum_, false, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:tensorflow.BoundedTensorSpecProto)
  return target;
}

int BoundedTensorSpecProto::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:tensorflow.BoundedTensorSpecProto)
  int total_size = 0;

  // optional string name = 1;
  if (this->name().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }

  // optional .tensorflow.TensorShapeProto shape = 2;
  if (this->has_shape()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->shape_);
  }

  // optional .tensorflow.DataType dtype = 3;
  if (this->dtype() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->dtype());
  }

  // optional .tensorflow.TensorProto minimum = 4;
  if (this->has_minimum()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->minimum_);
  }

  // optional .tensorflow.TensorProto maximum = 5;
  if (this->has_maximum()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->maximum_);
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BoundedTensorSpecProto::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:tensorflow.BoundedTensorSpecProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const BoundedTensorSpecProto* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const BoundedTensorSpecProto>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:tensorflow.BoundedTensorSpecProto)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:tensorflow.BoundedTensorSpecProto)
    MergeFrom(*source);
  }
}

void BoundedTensorSpecProto::MergeFrom(const BoundedTensorSpecProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tensorflow.BoundedTensorSpecProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.name().size() > 0) {

    name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  if (from.has_shape()) {
    mutable_shape()->::tensorflow::TensorShapeProto::MergeFrom(from.shape());
  }
  if (from.dtype() != 0) {
    set_dtype(from.dtype());
  }
  if (from.has_minimum()) {
    mutable_minimum()->::tensorflow::TensorProto::MergeFrom(from.minimum());
  }
  if (from.has_maximum()) {
    mutable_maximum()->::tensorflow::TensorProto::MergeFrom(from.maximum());
  }
}

void BoundedTensorSpecProto::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:tensorflow.BoundedTensorSpecProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BoundedTensorSpecProto::CopyFrom(const BoundedTensorSpecProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tensorflow.BoundedTensorSpecProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BoundedTensorSpecProto::IsInitialized() const {

  return true;
}

void BoundedTensorSpecProto::Swap(BoundedTensorSpecProto* other) {
  if (other == this) return;
  InternalSwap(other);
}
void BoundedTensorSpecProto::InternalSwap(BoundedTensorSpecProto* other) {
  name_.Swap(&other->name_);
  std::swap(shape_, other->shape_);
  std::swap(dtype_, other->dtype_);
  std::swap(minimum_, other->minimum_);
  std::swap(maximum_, other->maximum_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata BoundedTensorSpecProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BoundedTensorSpecProto_descriptor_;
  metadata.reflection = BoundedTensorSpecProto_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// BoundedTensorSpecProto

// optional string name = 1;
void BoundedTensorSpecProto::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& BoundedTensorSpecProto::name() const {
  // @@protoc_insertion_point(field_get:tensorflow.BoundedTensorSpecProto.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void BoundedTensorSpecProto::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.BoundedTensorSpecProto.name)
}
 void BoundedTensorSpecProto::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.BoundedTensorSpecProto.name)
}
 void BoundedTensorSpecProto::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.BoundedTensorSpecProto.name)
}
 ::std::string* BoundedTensorSpecProto::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.BoundedTensorSpecProto.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* BoundedTensorSpecProto::release_name() {
  // @@protoc_insertion_point(field_release:tensorflow.BoundedTensorSpecProto.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void BoundedTensorSpecProto::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.BoundedTensorSpecProto.name)
}

// optional .tensorflow.TensorShapeProto shape = 2;
bool BoundedTensorSpecProto::has_shape() const {
  return !_is_default_instance_ && shape_ != NULL;
}
void BoundedTensorSpecProto::clear_shape() {
  if (GetArenaNoVirtual() == NULL && shape_ != NULL) delete shape_;
  shape_ = NULL;
}
const ::tensorflow::TensorShapeProto& BoundedTensorSpecProto::shape() const {
  // @@protoc_insertion_point(field_get:tensorflow.BoundedTensorSpecProto.shape)
  return shape_ != NULL ? *shape_ : *default_instance_->shape_;
}
::tensorflow::TensorShapeProto* BoundedTensorSpecProto::mutable_shape() {
  
  if (shape_ == NULL) {
    shape_ = new ::tensorflow::TensorShapeProto;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.BoundedTensorSpecProto.shape)
  return shape_;
}
::tensorflow::TensorShapeProto* BoundedTensorSpecProto::release_shape() {
  // @@protoc_insertion_point(field_release:tensorflow.BoundedTensorSpecProto.shape)
  
  ::tensorflow::TensorShapeProto* temp = shape_;
  shape_ = NULL;
  return temp;
}
void BoundedTensorSpecProto::set_allocated_shape(::tensorflow::TensorShapeProto* shape) {
  delete shape_;
  if (shape != NULL && shape->GetArena() != NULL) {
    ::tensorflow::TensorShapeProto* new_shape = new ::tensorflow::TensorShapeProto;
    new_shape->CopyFrom(*shape);
    shape = new_shape;
  }
  shape_ = shape;
  if (shape) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.BoundedTensorSpecProto.shape)
}

// optional .tensorflow.DataType dtype = 3;
void BoundedTensorSpecProto::clear_dtype() {
  dtype_ = 0;
}
 ::tensorflow::DataType BoundedTensorSpecProto::dtype() const {
  // @@protoc_insertion_point(field_get:tensorflow.BoundedTensorSpecProto.dtype)
  return static_cast< ::tensorflow::DataType >(dtype_);
}
 void BoundedTensorSpecProto::set_dtype(::tensorflow::DataType value) {
  
  dtype_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.BoundedTensorSpecProto.dtype)
}

// optional .tensorflow.TensorProto minimum = 4;
bool BoundedTensorSpecProto::has_minimum() const {
  return !_is_default_instance_ && minimum_ != NULL;
}
void BoundedTensorSpecProto::clear_minimum() {
  if (GetArenaNoVirtual() == NULL && minimum_ != NULL) delete minimum_;
  minimum_ = NULL;
}
const ::tensorflow::TensorProto& BoundedTensorSpecProto::minimum() const {
  // @@protoc_insertion_point(field_get:tensorflow.BoundedTensorSpecProto.minimum)
  return minimum_ != NULL ? *minimum_ : *default_instance_->minimum_;
}
::tensorflow::TensorProto* BoundedTensorSpecProto::mutable_minimum() {
  
  if (minimum_ == NULL) {
    minimum_ = new ::tensorflow::TensorProto;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.BoundedTensorSpecProto.minimum)
  return minimum_;
}
::tensorflow::TensorProto* BoundedTensorSpecProto::release_minimum() {
  // @@protoc_insertion_point(field_release:tensorflow.BoundedTensorSpecProto.minimum)
  
  ::tensorflow::TensorProto* temp = minimum_;
  minimum_ = NULL;
  return temp;
}
void BoundedTensorSpecProto::set_allocated_minimum(::tensorflow::TensorProto* minimum) {
  delete minimum_;
  if (minimum != NULL && minimum->GetArena() != NULL) {
    ::tensorflow::TensorProto* new_minimum = new ::tensorflow::TensorProto;
    new_minimum->CopyFrom(*minimum);
    minimum = new_minimum;
  }
  minimum_ = minimum;
  if (minimum) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.BoundedTensorSpecProto.minimum)
}

// optional .tensorflow.TensorProto maximum = 5;
bool BoundedTensorSpecProto::has_maximum() const {
  return !_is_default_instance_ && maximum_ != NULL;
}
void BoundedTensorSpecProto::clear_maximum() {
  if (GetArenaNoVirtual() == NULL && maximum_ != NULL) delete maximum_;
  maximum_ = NULL;
}
const ::tensorflow::TensorProto& BoundedTensorSpecProto::maximum() const {
  // @@protoc_insertion_point(field_get:tensorflow.BoundedTensorSpecProto.maximum)
  return maximum_ != NULL ? *maximum_ : *default_instance_->maximum_;
}
::tensorflow::TensorProto* BoundedTensorSpecProto::mutable_maximum() {
  
  if (maximum_ == NULL) {
    maximum_ = new ::tensorflow::TensorProto;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.BoundedTensorSpecProto.maximum)
  return maximum_;
}
::tensorflow::TensorProto* BoundedTensorSpecProto::release_maximum() {
  // @@protoc_insertion_point(field_release:tensorflow.BoundedTensorSpecProto.maximum)
  
  ::tensorflow::TensorProto* temp = maximum_;
  maximum_ = NULL;
  return temp;
}
void BoundedTensorSpecProto::set_allocated_maximum(::tensorflow::TensorProto* maximum) {
  delete maximum_;
  if (maximum != NULL && maximum->GetArena() != NULL) {
    ::tensorflow::TensorProto* new_maximum = new ::tensorflow::TensorProto;
    new_maximum->CopyFrom(*maximum);
    maximum = new_maximum;
  }
  maximum_ = maximum;
  if (maximum) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.BoundedTensorSpecProto.maximum)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* TypeSpecProto_TypeSpecClass_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TypeSpecProto_TypeSpecClass_descriptor_;
}
bool TypeSpecProto_TypeSpecClass_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const TypeSpecProto_TypeSpecClass TypeSpecProto::UNKNOWN;
const TypeSpecProto_TypeSpecClass TypeSpecProto::SPARSE_TENSOR_SPEC;
const TypeSpecProto_TypeSpecClass TypeSpecProto::INDEXED_SLICES_SPEC;
const TypeSpecProto_TypeSpecClass TypeSpecProto::RAGGED_TENSOR_SPEC;
const TypeSpecProto_TypeSpecClass TypeSpecProto::TENSOR_ARRAY_SPEC;
const TypeSpecProto_TypeSpecClass TypeSpecProto::DATA_DATASET_SPEC;
const TypeSpecProto_TypeSpecClass TypeSpecProto::DATA_ITERATOR_SPEC;
const TypeSpecProto_TypeSpecClass TypeSpecProto::OPTIONAL_SPEC;
const TypeSpecProto_TypeSpecClass TypeSpecProto::PER_REPLICA_SPEC;
const TypeSpecProto_TypeSpecClass TypeSpecProto::VARIABLE_SPEC;
const TypeSpecProto_TypeSpecClass TypeSpecProto::ROW_PARTITION_SPEC;
const TypeSpecProto_TypeSpecClass TypeSpecProto::TypeSpecClass_MIN;
const TypeSpecProto_TypeSpecClass TypeSpecProto::TypeSpecClass_MAX;
const int TypeSpecProto::TypeSpecClass_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TypeSpecProto::kTypeSpecClassFieldNumber;
const int TypeSpecProto::kTypeStateFieldNumber;
const int TypeSpecProto::kTypeSpecClassNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TypeSpecProto::TypeSpecProto()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:tensorflow.TypeSpecProto)
}

void TypeSpecProto::InitAsDefaultInstance() {
  _is_default_instance_ = true;
  type_state_ = const_cast< ::tensorflow::StructuredValue*>(&::tensorflow::StructuredValue::default_instance());
}

TypeSpecProto::TypeSpecProto(const TypeSpecProto& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:tensorflow.TypeSpecProto)
}

void TypeSpecProto::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  type_spec_class_ = 0;
  type_state_ = NULL;
  type_spec_class_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

TypeSpecProto::~TypeSpecProto() {
  // @@protoc_insertion_point(destructor:tensorflow.TypeSpecProto)
  SharedDtor();
}

void TypeSpecProto::SharedDtor() {
  type_spec_class_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete type_state_;
  }
}

void TypeSpecProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TypeSpecProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TypeSpecProto_descriptor_;
}

const TypeSpecProto& TypeSpecProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_tensorflow_2fcore_2fprotobuf_2fstruct_2eproto();
  return *default_instance_;
}

TypeSpecProto* TypeSpecProto::default_instance_ = NULL;

TypeSpecProto* TypeSpecProto::New(::google::protobuf::Arena* arena) const {
  TypeSpecProto* n = new TypeSpecProto;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TypeSpecProto::Clear() {
// @@protoc_insertion_point(message_clear_start:tensorflow.TypeSpecProto)
  type_spec_class_ = 0;
  if (GetArenaNoVirtual() == NULL && type_state_ != NULL) delete type_state_;
  type_state_ = NULL;
  type_spec_class_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool TypeSpecProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:tensorflow.TypeSpecProto)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .tensorflow.TypeSpecProto.TypeSpecClass type_spec_class = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_type_spec_class(static_cast< ::tensorflow::TypeSpecProto_TypeSpecClass >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_type_state;
        break;
      }

      // optional .tensorflow.StructuredValue type_state = 2;
      case 2: {
        if (tag == 18) {
         parse_type_state:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_type_state()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_type_spec_class_name;
        break;
      }

      // optional string type_spec_class_name = 3;
      case 3: {
        if (tag == 26) {
         parse_type_spec_class_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_type_spec_class_name()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->type_spec_class_name().data(), this->type_spec_class_name().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "tensorflow.TypeSpecProto.type_spec_class_name"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:tensorflow.TypeSpecProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:tensorflow.TypeSpecProto)
  return false;
#undef DO_
}

void TypeSpecProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:tensorflow.TypeSpecProto)
  // optional .tensorflow.TypeSpecProto.TypeSpecClass type_spec_class = 1;
  if (this->type_spec_class() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type_spec_class(), output);
  }

  // optional .tensorflow.StructuredValue type_state = 2;
  if (this->has_type_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->type_state_, output);
  }

  // optional string type_spec_class_name = 3;
  if (this->type_spec_class_name().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->type_spec_class_name().data(), this->type_spec_class_name().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "tensorflow.TypeSpecProto.type_spec_class_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->type_spec_class_name(), output);
  }

  // @@protoc_insertion_point(serialize_end:tensorflow.TypeSpecProto)
}

::google::protobuf::uint8* TypeSpecProto::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:tensorflow.TypeSpecProto)
  // optional .tensorflow.TypeSpecProto.TypeSpecClass type_spec_class = 1;
  if (this->type_spec_class() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type_spec_class(), target);
  }

  // optional .tensorflow.StructuredValue type_state = 2;
  if (this->has_type_state()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->type_state_, false, target);
  }

  // optional string type_spec_class_name = 3;
  if (this->type_spec_class_name().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->type_spec_class_name().data(), this->type_spec_class_name().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "tensorflow.TypeSpecProto.type_spec_class_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->type_spec_class_name(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:tensorflow.TypeSpecProto)
  return target;
}

int TypeSpecProto::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:tensorflow.TypeSpecProto)
  int total_size = 0;

  // optional .tensorflow.TypeSpecProto.TypeSpecClass type_spec_class = 1;
  if (this->type_spec_class() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type_spec_class());
  }

  // optional .tensorflow.StructuredValue type_state = 2;
  if (this->has_type_state()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->type_state_);
  }

  // optional string type_spec_class_name = 3;
  if (this->type_spec_class_name().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->type_spec_class_name());
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TypeSpecProto::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:tensorflow.TypeSpecProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const TypeSpecProto* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const TypeSpecProto>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:tensorflow.TypeSpecProto)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:tensorflow.TypeSpecProto)
    MergeFrom(*source);
  }
}

void TypeSpecProto::MergeFrom(const TypeSpecProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tensorflow.TypeSpecProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.type_spec_class() != 0) {
    set_type_spec_class(from.type_spec_class());
  }
  if (from.has_type_state()) {
    mutable_type_state()->::tensorflow::StructuredValue::MergeFrom(from.type_state());
  }
  if (from.type_spec_class_name().size() > 0) {

    type_spec_class_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.type_spec_class_name_);
  }
}

void TypeSpecProto::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:tensorflow.TypeSpecProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TypeSpecProto::CopyFrom(const TypeSpecProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tensorflow.TypeSpecProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TypeSpecProto::IsInitialized() const {

  return true;
}

void TypeSpecProto::Swap(TypeSpecProto* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TypeSpecProto::InternalSwap(TypeSpecProto* other) {
  std::swap(type_spec_class_, other->type_spec_class_);
  std::swap(type_state_, other->type_state_);
  type_spec_class_name_.Swap(&other->type_spec_class_name_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TypeSpecProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TypeSpecProto_descriptor_;
  metadata.reflection = TypeSpecProto_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TypeSpecProto

// optional .tensorflow.TypeSpecProto.TypeSpecClass type_spec_class = 1;
void TypeSpecProto::clear_type_spec_class() {
  type_spec_class_ = 0;
}
 ::tensorflow::TypeSpecProto_TypeSpecClass TypeSpecProto::type_spec_class() const {
  // @@protoc_insertion_point(field_get:tensorflow.TypeSpecProto.type_spec_class)
  return static_cast< ::tensorflow::TypeSpecProto_TypeSpecClass >(type_spec_class_);
}
 void TypeSpecProto::set_type_spec_class(::tensorflow::TypeSpecProto_TypeSpecClass value) {
  
  type_spec_class_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.TypeSpecProto.type_spec_class)
}

// optional .tensorflow.StructuredValue type_state = 2;
bool TypeSpecProto::has_type_state() const {
  return !_is_default_instance_ && type_state_ != NULL;
}
void TypeSpecProto::clear_type_state() {
  if (GetArenaNoVirtual() == NULL && type_state_ != NULL) delete type_state_;
  type_state_ = NULL;
}
const ::tensorflow::StructuredValue& TypeSpecProto::type_state() const {
  // @@protoc_insertion_point(field_get:tensorflow.TypeSpecProto.type_state)
  return type_state_ != NULL ? *type_state_ : *default_instance_->type_state_;
}
::tensorflow::StructuredValue* TypeSpecProto::mutable_type_state() {
  
  if (type_state_ == NULL) {
    type_state_ = new ::tensorflow::StructuredValue;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.TypeSpecProto.type_state)
  return type_state_;
}
::tensorflow::StructuredValue* TypeSpecProto::release_type_state() {
  // @@protoc_insertion_point(field_release:tensorflow.TypeSpecProto.type_state)
  
  ::tensorflow::StructuredValue* temp = type_state_;
  type_state_ = NULL;
  return temp;
}
void TypeSpecProto::set_allocated_type_state(::tensorflow::StructuredValue* type_state) {
  delete type_state_;
  type_state_ = type_state;
  if (type_state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TypeSpecProto.type_state)
}

// optional string type_spec_class_name = 3;
void TypeSpecProto::clear_type_spec_class_name() {
  type_spec_class_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& TypeSpecProto::type_spec_class_name() const {
  // @@protoc_insertion_point(field_get:tensorflow.TypeSpecProto.type_spec_class_name)
  return type_spec_class_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TypeSpecProto::set_type_spec_class_name(const ::std::string& value) {
  
  type_spec_class_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.TypeSpecProto.type_spec_class_name)
}
 void TypeSpecProto::set_type_spec_class_name(const char* value) {
  
  type_spec_class_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.TypeSpecProto.type_spec_class_name)
}
 void TypeSpecProto::set_type_spec_class_name(const char* value, size_t size) {
  
  type_spec_class_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.TypeSpecProto.type_spec_class_name)
}
 ::std::string* TypeSpecProto::mutable_type_spec_class_name() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.TypeSpecProto.type_spec_class_name)
  return type_spec_class_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* TypeSpecProto::release_type_spec_class_name() {
  // @@protoc_insertion_point(field_release:tensorflow.TypeSpecProto.type_spec_class_name)
  
  return type_spec_class_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TypeSpecProto::set_allocated_type_spec_class_name(::std::string* type_spec_class_name) {
  if (type_spec_class_name != NULL) {
    
  } else {
    
  }
  type_spec_class_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type_spec_class_name);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TypeSpecProto.type_spec_class_name)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace tensorflow

// @@protoc_insertion_point(global_scope)
